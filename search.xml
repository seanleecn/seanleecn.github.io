<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Git学习笔记</title>
    <url>/2021/01/21/Git%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<p>作为一个面向Github科研的研究生，熟练掌握<code>git clone</code>的一百种方法。</p>
<p>师兄搭了个GitLab进行多人同步开发，这里根据<a href="https://www.liaoxuefeng.com/wiki/896043488029600">廖雪峰的Git教程</a>的整理一份个人的学习笔记</p>
<a id="more"></a>

<blockquote>
<p>开篇先推荐一下阮一峰整理的两份Git命令(<a href="https://www.ruanyifeng.com/blog/2015/12/git-cheat-sheet.html">资料1</a>，<a href="http://www.ruanyifeng.com/blog/2014/06/git_remote.html">资料2</a>)，比我整理的好多了~</p>
</blockquote>
<h1 id="Git本地仓库命令"><a href="#Git本地仓库命令" class="headerlink" title="Git本地仓库命令"></a>Git本地仓库命令</h1><h2 id="基本单分支操作"><a href="#基本单分支操作" class="headerlink" title="基本单分支操作"></a>基本单分支操作</h2><ul>
<li><p>建立本地仓库</p>
<p><code>git init</code></p>
</li>
<li><p>添加文件到本地仓库</p>
<p><code>git add .</code></p>
</li>
<li><p>提交文件到本地仓库</p>
<p><code>git commit -m &quot;做了啥改动&quot;</code></p>
<blockquote>
<p>add操作可以多次执行，然后1次commit操作打包提交</p>
</blockquote>
</li>
<li><p>查看本地仓库状态</p>
<p><code>git status</code></p>
</li>
<li><p>版本回溯</p>
<p>  每一次commit操作，相当于打上一个“存档点”，因此可以通过commit记录回到过去</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 查看commit的历史记录</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line">commit c43cbeab0fbee5b344415c6ec7d44cac51f857f6 (HEAD -&gt; master)</span><br><span class="line">Author: lixiang &lt;lix0419@outlook.com&gt;</span><br><span class="line">Date:   Wed Jan 20 21:23:51 2021 +0800</span><br><span class="line"></span><br><span class="line">    reset_test添加commit 2行</span><br><span class="line"></span><br><span class="line">commit 9bc12b122bd803e9ded5af5b10ae805257b00312</span><br><span class="line">Author: lixiang &lt;lix0419@outlook.com&gt;</span><br><span class="line">Date:   Wed Jan 20 21:22:42 2021 +0800</span><br><span class="line"></span><br><span class="line">    添加<span class="built_in">test</span>文件夹</span><br></pre></td></tr></table></figure>

<p>  当前在c43cb…这个<strong>HEAD</strong>节点上。上一个版本就是<strong>HEAD^</strong>，上100个版本是<strong>HEAD~100</strong></p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 回退版本</span></span><br><span class="line">$ git reset --hard HEAD^</span><br><span class="line"><span class="comment"># 再次git log</span></span><br><span class="line">$ git <span class="built_in">log</span> </span><br><span class="line">commit 9bc12b122bd803e9ded5af5b10ae805257b00312 (HEAD -&gt; master)</span><br><span class="line">Author: lixiang &lt;lix0419@outlook.com&gt;</span><br><span class="line">Date:   Wed Jan 20 21:22:42 2021 +0800</span><br><span class="line"></span><br><span class="line">    添加<span class="built_in">test</span>文件夹</span><br></pre></td></tr></table></figure>

<p>  发现我们丢失了最后一次commit的东西，如果后悔的话，可以通过制定commit的id来找回</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">   9bc12b1 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to HEAD^</span><br><span class="line">   c43cbea HEAD@&#123;1&#125;: commit: reset_test添加commit 2行</span><br><span class="line">   9bc12b1 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit: 添加<span class="built_in">test</span>文件夹</span><br><span class="line">   87bd242 HEAD@&#123;3&#125;: commit: 修改笔记</span><br><span class="line">   722f491 HEAD@&#123;4&#125;: commit: add readme</span><br><span class="line">   3d224cd HEAD@&#123;5&#125;: commit (initial): 添加[本地仓库]笔记</span><br></pre></td></tr></table></figure>
<p>  reflog命令记录了全部的操作，reset之前的id为c43cbea</p>
  <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 撤销reset操作</span></span><br><span class="line">git reset --hard c43cbea</span><br></pre></td></tr></table></figure></li>
<li><p>撤销修改</p>
<p>当改动了本地库的文件，需要撤销的时候，可以通过git checkout命令撤下修改</p>
<blockquote>
<p>对于vscode的用户，这一部分直接在vscode自带的版本控制栏里面点点点就完事了…</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 当没有执行git add操作的时候，将回到上一次commit后的情况</span></span><br><span class="line">$ git checkout -- <span class="built_in">test</span>/checkout_test.txt</span><br><span class="line"><span class="comment"># 当执行了git add操作的时候，将回到上次add后的情况</span></span><br><span class="line">$ git status</span><br><span class="line">位于分支 master</span><br><span class="line">要提交的变更：</span><br><span class="line">  （使用 <span class="string">&quot;git reset HEAD &lt;文件&gt;...&quot;</span> 以取消暂存）</span><br><span class="line"></span><br><span class="line">          修改：     <span class="built_in">test</span>/checkout_test.txt</span><br><span class="line"><span class="comment"># 所以撤销add操作的命令为</span></span><br><span class="line">$ git reset HEAD <span class="built_in">test</span>/checkout_test.txt</span><br></pre></td></tr></table></figure></li>
<li><p>删除文件</p>
<p>当文件已经被commit之后，想要删除它(不再使用git跟踪修改)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rm <span class="built_in">test</span>/rm_test.txt</span><br><span class="line">git commit -m <span class="string">&quot;remove rm_test.txt&quot;</span></span><br></pre></td></tr></table></figure>
<h2 id="多分支操作"><a href="#多分支操作" class="headerlink" title="多分支操作"></a>多分支操作</h2></li>
<li><p>创建分支</p>
<blockquote>
<p>创建分支实际上是建立了一个指针指向当前的commit，同时HEAD指针指向dev</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># -b表示创建并切换</span></span><br><span class="line">git checkout -b dev</span><br><span class="line"><span class="comment"># 等效于下面</span></span><br><span class="line">git branch dev</span><br><span class="line">git checkout dev</span><br><span class="line"><span class="comment"># 查看当前分支</span></span><br><span class="line">git branch</span><br></pre></td></tr></table></figure></li>
<li><p>合并分支</p>
<blockquote>
<p>在一个分支上面进行修改并<strong>commit之后</strong>，切回master分支，进行合并分支</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 回到主分支，此时修改没了</span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="comment"># 把dev分支合并到master上面去</span></span><br><span class="line">git merge dev</span><br><span class="line"><span class="comment"># 删除dev分支</span></span><br><span class="line">git branch -d dev</span><br></pre></td></tr></table></figure></li>
<li><p>切换分支</p>
<blockquote>
<p>git checkout命令既可以切换分支，也可以撤销修改，为了避免迷惑，在git 2.23版本引入了switch命令。目前Ubuntu18的官方apt安装的git是2.17.1版本，还不支持这个特性。。。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建并切换</span></span><br><span class="line">git switch -c dev</span><br><span class="line"><span class="comment"># 仅切换</span></span><br><span class="line">git switch master</span><br></pre></td></tr></table></figure>
</li>
<li><p>分支冲突</p>
<blockquote>
<p>回顾上面的分支合并操作，新建的dev分支上面的commit是领先于master的，也就是说在切出dev分支之后，master分支没有进行过commit。当master和deb分支都进行了commit，就要解决分支冲突的问题。</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 创建新的分支</span></span><br><span class="line">git checkout -b dev1</span><br><span class="line"><span class="comment"># 修改一些文件后提交commit(在dev1分支)</span></span><br><span class="line"><span class="comment"># 切回master分支</span></span><br><span class="line">git checkout master</span><br><span class="line"><span class="comment"># 尝试合并</span></span><br><span class="line">git merge dev1</span><br><span class="line"><span class="comment"># 出现冲突解决后成功合并，可以看一下此时的时间线</span></span><br><span class="line">$ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   85aa805 (HEAD -&gt; master) Merge branch <span class="string">&#x27;dev1&#x27;</span></span><br><span class="line">  |\  </span><br><span class="line">  | * ef82add (dev1) 测试冲突</span><br><span class="line">  * | ecaecfb 测试冲突-在master上进行commit</span><br><span class="line">  |/  </span><br><span class="line">  * d401351 增加dev分支</span><br><span class="line"><span class="comment"># 删除dev1分支</span></span><br><span class="line">git branch -d dev1</span><br></pre></td></tr></table></figure>
<h1 id="Git远程仓库命令"><a href="#Git远程仓库命令" class="headerlink" title="Git远程仓库命令"></a>Git远程仓库命令</h1></li>
</ul>
<blockquote>
<p>没有配置好Github的ssh秘钥的话参考<a href="https://docs.github.com/cn/github/authenticating-to-github/connecting-to-github-with-ssh">Github官网教程</a></p>
</blockquote>
<ul>
<li><p>本地仓库关联远程仓库</p>
<p><code>git remote add origin git@github.com:seanleecn/learn_git.git</code></p>
<blockquote>
<p>这样就添加了一个名字叫做origin的远程仓库</p>
</blockquote>
</li>
<li><p>本地首次推送远程</p>
<p><code>git push -u origin master</code></p>
<blockquote>
<p>注意1：2020年10月开始，Github为了XX政治正确，将默认分支的名称从master改为了main，但是本地的默认是在master分支的。建议修改Github的<a href="https://github.com/settings/repositories">默认新建分支</a>为master。</p>
<p>注意2：建仓库的时候不要新建readme文件，否则远程就多了一次commit</p>
</blockquote>
</li>
<li><p>克隆远程仓库</p>
<p><code>git clone xxx</code></p>
<p>从远程仓库克隆时，实际上Git自动把本地的master分支和远程的master分支对应起来了，并且，远程仓库的默认名称(在本地仓库的角度看)是origin</p>
</li>
<li><p>查看远程库</p>
<p><code>git remote -v</code></p>
</li>
<li><p>推送分支</p>
<p><code>git push origin master</code></p>
<p>上面这句话的意思是把本地的master推送到origin这个远程库上</p>
<p>这里需要<strong>注意</strong>的是，在push命令中并没有指定远程库的分支。前面说过clone下来的库默认把本地的master和远程的master关联起来，但是当有多个分支的时候，就会出现问题。</p>
</li>
<li><p>多分支仓库的多人协作</p>
<p>当克隆一个多分支的仓库的时候，只是把master分支拉到了本地</p>
<p>比如想要在本地dev分支上面继续origin上面的dev分支开发，需要把远程的dev分支拉到本地的dev分支上面</p>
<p><code>git checkout -b dev origin/dev</code></p>
<p>之后就可以在dev上面修改并推送到origin/dev</p>
<p>当一个仓库是由多人维护的时候，存在origin的提交比我们本地更靠前的情况(也就是别人已经往origin上面推几个commit)，这时候需要先把远程的修改拉到本地</p>
<p><code>git pull</code></p>
<p>如果<code>git pull</code>提示<code>no tracking information</code>，说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code></p>
</li>
<li><p>一个本地库关联多个远程库</p>
<p>举个应用情景的例子：</p>
<ul>
<li>从Github直接clone了一个程序，改啊改啊改啊，当我想要push到Github上面的时候，因为不是fork之后再clone，没有权限push，这时候就需要链接一个新的远程库</li>
</ul>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 添加一个新的远程库，注意不能叫origin了</span></span><br><span class="line">git remote add my_repo git@github.com:seanleecn/learn_git.git</span><br><span class="line"><span class="comment"># 这时候可以指定push的远程库</span></span><br><span class="line">git push github master</span><br></pre></td></tr></table></figure>
<h1 id="Git的自定义"><a href="#Git的自定义" class="headerlink" title="Git的自定义"></a>Git的自定义</h1></li>
<li><p>.gitignore文件</p>
<p><code>.gitignore</code>文件可以忽略一些中间生成文件(比如build目录)，其语法是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 排除所有.class文件:</span><br><span class="line">*.class</span><br><span class="line"># 不排除.gitignore</span><br><span class="line">!.gitignore</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu18配置Pytorch环境</title>
    <url>/2021/01/05/Ubuntu18%E9%85%8D%E7%BD%AEPytorch%E7%8E%AF%E5%A2%83/</url>
    <content><![CDATA[<p>网上大部分的教程都是按照<code>driver-&gt;cuda-&gt;cudnn-&gt;pytorch</code>这一顺序进行环境配置的。</p>
<p>这篇文章从最终目标出发，从pytorch逆向分析环境依赖。</p>
<a id="more"></a>

<h1 id="环境说明"><a href="#环境说明" class="headerlink" title="环境说明"></a>环境说明</h1><p>ubuntu18.04 + nvidia 1080显卡，显卡驱动在<strong>软件和更新</strong>里面通过附件驱动安装。</p>
<h1 id="分析流程"><a href="#分析流程" class="headerlink" title="分析流程"></a>分析流程</h1><p>配置环境主要是每个环境的依赖要搞明白，一般是向下兼容的，下面说一下自己的思路。</p>
<ol>
<li><p>打开<a href="https://pytorch.org/">pytorch官网</a>，选择一个自己想要的版本</p>
<img src="/2021/01/05/Ubuntu18%E9%85%8D%E7%BD%AEPytorch%E7%8E%AF%E5%A2%83/image-20210105202828030.png" class="" title="image-20210105202828030">

<p>我这里选择了倒数第二个支持GPU的版本，这里告诉我们<strong>需要CUDA10.2</strong>。</p>
</li>
<li><p>安装cuda</p>
<ul>
<li><p>打开<a href="https://developer.nvidia.com/zh-cn/cuda-downloads">cuda官网</a>，找到自己需要的10.2版本。</p>
</li>
<li><p>选择runfile离线安装（不选择deb离线安装是因为deb安装会产生一堆文件在/var路径下，本洁癖还不知敢不敢删除）</p>
</li>
<li><p>观察下载文件的名字，以10.2的cuda为例子</p>
<img src="/2021/01/05/Ubuntu18%E9%85%8D%E7%BD%AEPytorch%E7%8E%AF%E5%A2%83/image-20210105203917080.png" class="" title="image-20210105203917080">

<p>标出来的就是10.2版本的CUDA最低需要的驱动版本号，也就是<strong>440.33</strong>。</p>
</li>
</ul>
</li>
<li><p>安装cudnn</p>
<p>cudnn的<a href="https://developer.nvidia.com/rdp/cudnn-download">官网</a>的下载界面标出来cuda和cudnn的对应关系，选择和cuda10.2对应的cudnn8.0.5下载，这里依旧不选择deb安装，下载tar压缩包，根据<a href="https://docs.nvidia.com/deeplearning/cudnn/install-guide/index.html#installlinux-tar">官方文档</a>安装。</p>
</li>
<li><p>安装显卡驱动</p>
<p>打开软件和更新里面的附加硬件，选择一个版本号<strong>大于</strong>440.33的metapackage安装</p>
<img src="/2021/01/05/Ubuntu18%E9%85%8D%E7%BD%AEPytorch%E7%8E%AF%E5%A2%83/image-20210105204626321.png" class="" title="image-20210105204626321">

</li>
</ol>
<h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>最后安装的时候还是要按照<code>driver-&gt;cuda-&gt;cudnn-&gt;pytorch</code>的顺序进行~需要注意的是，安装cuda的时候把driver选项关闭，因为我们通过<code>软件和更新里面的附加硬件</code>安装了满足当前cuda依赖的驱动。</p>
<h1 id="BUG修复"><a href="#BUG修复" class="headerlink" title="BUG修复"></a>BUG修复</h1><p>在使用tar压缩包，且按照官网的教程安装cudnn之后，当遇到运行库的链接操作时，会出现下面的错误：</p>
<blockquote>
<p>/sbin/ldconfig.real: /usr/local/cuda-10.2/targets/x86_64-linux/lib/libcudnn_ops_train.so.8 is not a symbolic link</p>
<p>/sbin/ldconfig.real: /usr/local/cuda-10.2/targets/x86_64-linux/lib/libcudnn.so.8 is not a symbolic link</p>
<p>…</p>
</blockquote>
<p>原因是安装cudnn的cp命令，没有把软连接复制过去，而是把源文件复制了一份。<br>在<code>/usr/local/cuda-10.2/targets/x86_64-linux/lib/</code>路径下通过<code>ls -l</code>显示软连接的真是路径可以找到原始指向文件，发现没有报错的库文件链接的顺序是<code>libxxx.so-&gt;libxxx.so.8-&gt;libxxx.8.0.5</code>，所以按照下面顺序恢复链接顺序。(报错的文件共7个)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment">#1</span></span><br><span class="line">sudo ln -sf libcudnn_adv_infer.so.8.0.5 libcudnn_adv_infer.so.8</span><br><span class="line"></span><br><span class="line">sudo ln -sf libcudnn_adv_infer.so.8 libcudnn_adv_infer.so</span><br><span class="line"></span><br><span class="line"><span class="comment">#2</span></span><br><span class="line">sudo ln -sf libcudnn_adv_train.so.8.0.5 libcudnn_adv_train.so.8</span><br><span class="line"></span><br><span class="line">sudo ln -sf libcudnn_adv_train.so.8 libcudnn_adv_train.so</span><br><span class="line"></span><br><span class="line"><span class="comment">#3</span></span><br><span class="line">sudo ln -sf libcudnn_cnn_infer.so.8.0.5 libcudnn_cnn_infer.so.8</span><br><span class="line"></span><br><span class="line">sudo ln -sf libcudnn_cnn_infer.so.8 libcudnn_cnn_infer.so</span><br><span class="line"></span><br><span class="line"><span class="comment">#4</span></span><br><span class="line">sudo ln -sf libcudnn_cnn_train.so.8.0.5 libcudnn_cnn_train.so.8</span><br><span class="line"></span><br><span class="line">sudo ln -sf libcudnn_cnn_train.so.8 libcudnn_cnn_train.so</span><br><span class="line"></span><br><span class="line"><span class="comment">#5</span></span><br><span class="line">sudo ln -sf libcudnn_ops_infer.so.8.0.5 libcudnn_ops_infer.so.8</span><br><span class="line"></span><br><span class="line">sudo ln -sf libcudnn_ops_infer.so.8 libcudnn_ops_infer.so</span><br><span class="line"></span><br><span class="line"><span class="comment">#6</span></span><br><span class="line">sudo ln -sf libcudnn_ops_train.so.8.0.5 libcudnn_ops_train.so.8</span><br><span class="line"></span><br><span class="line">sudo ln -sf libcudnn_ops_train.so.8 libcudnn_ops_train.so</span><br><span class="line"></span><br><span class="line"><span class="comment">#7</span></span><br><span class="line">sudo ln -sf libcudnn.so.8.0.5 libcudnn.so.8</span><br><span class="line"></span><br><span class="line">sudo ln -sf libcudnn.so.8 libcudnn.so</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>Pytorch</tag>
      </tags>
  </entry>
  <entry>
    <title>Github+Hexo搭建个人博客，备份，SEO优化全纪录</title>
    <url>/2020/07/05/github+hexo%E5%88%B6%E4%BD%9C%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<h1 id="Github-Hexo制作个人博客"><a href="#Github-Hexo制作个人博客" class="headerlink" title="Github+Hexo制作个人博客"></a>Github+Hexo制作个人博客</h1><p>本篇文章是我搭建个人博客的记录，除了大部分博客中都提到的Github page托管网页静态文件，还实现了源文件备份的功能。</p>
<p>两份重要的文档：Hexo<a href="https://hexo.io/zh-cn/docs/">官方文档</a>，Next主题<a href="https://theme-next.js.org/">官方文档</a>。</p>
<a id="more"></a>

<h2 id="安装NodeJS"><a href="#安装NodeJS" class="headerlink" title="安装NodeJS"></a>安装NodeJS</h2><p>推荐通过apt安装，<a href="https://github.com/nodesource/distributions/blob/master/README.md">教程</a>。可以选择LTS(长期支持)源。</p>
<p><code>node -v</code>和<code>npm -v</code>有输出就可以。</p>
<blockquote>
<p>npm相关知识，详细的可以看<a href="https://www.kancloud.cn/shellway/npm-doc">npm教程</a>。本人对前端一窍不通…</p>
</blockquote>
<h2 id="安装Hexo命令行工具"><a href="#安装Hexo命令行工具" class="headerlink" title="安装Hexo命令行工具"></a>安装Hexo命令行工具</h2><p>和一步主要是为了能用全局命令安装hexo基本依赖。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<blockquote>
<p>sudo是为了解决npm全局权限问题，如果觉得不安全可以看上面的npm教程中<em>解决权限问题</em>一章。</p>
</blockquote>
<h2 id="添加github仓库并关联本地源文件"><a href="#添加github仓库并关联本地源文件" class="headerlink" title="添加github仓库并关联本地源文件"></a>添加github仓库并关联本地源文件</h2><p>这一步是最关键的，主要是建立一个仓库，把hexo生成的网页静态文件推送到main分支，hexo源文件推送到src分支。实现<strong>一个仓库管理源文件和网页文件</strong>的目的。</p>
<ol>
<li><p>在github添加一个仓库，仓库名字为<code>YOUR_NAME.github.io</code>，注意<strong>不能</strong>用私人仓库，且勾上<strong>初始化README</strong>文件。</p>
</li>
<li><p>克隆到本地(这里用的是ssh协议，可以免去后续push输密码的麻烦)</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:seanleecn/seanleecn.github.io.git</span><br></pre></td></tr></table></figure></li>
<li><p>本地建一个src分支，存放源文件，并关联到github的远程src分支</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git checkout -b src  <span class="comment">#建分支并切换</span></span><br><span class="line">mkdir hexo</span><br><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;create sources branch&quot;</span></span><br><span class="line">git push --set-upstream origin src <span class="comment">#推送到新的远程src分支</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><code>cd hexo</code>-&gt;<code>hexo init</code>-&gt;<code>npm install</code>。这三步过后，最基本的Hexo环境就安装好了，<code>hexo s</code>可以把博客本地部署到本地4000端口，按照提示打开<a href="http://localhost:4000/%E5%B0%B1%E8%83%BD%E7%9C%8B%E5%88%B0%E6%95%88%E6%9E%9C%E4%BA%86%E3%80%82%E8%BF%99%E4%B8%89%E6%9D%A1%E5%91%BD%E4%BB%A4%E7%9A%84%E5%81%9A%E7%9A%84%E5%86%85%E5%AE%B9%E5%A4%A7%E8%87%B4%E6%98%AF%60%60hexo">http://localhost:4000/就能看到效果了。这三条命令的做的内容大致是``hexo</a> init<code>生成了</code>package.json``文件，然后npm根据这个文件安装需要的包到node_modules文件夹下面。</p>
</li>
</ol>
<h2 id="网页推送到远程main分支"><a href="#网页推送到远程main分支" class="headerlink" title="网页推送到远程main分支"></a>网页推送到远程main分支</h2><p>我们需要把Hexo生成的界面推送到github的默认main分支上面，因此需要安装一个git deploy插件</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>
<blockquote>
<p><code>--save</code>命令会在安装模块到node_modules文件夹同时，把依赖写到package.json文件中，下次执行<code>npm install</code>就会安装这个包。</p>
</blockquote>
<p>然后在hexo文件夹下面的<code>_config.yml</code>中修改</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:seanleecn/seanleecn.github.io.git</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure>
<h1 id="博客备份使用说明"><a href="#博客备份使用说明" class="headerlink" title="博客备份使用说明"></a>博客备份使用说明</h1><p>至此配置完成了，每次要写博客前，先确认自己在<strong>src分支</strong>和<strong>hexo文件夹路径</strong>下，写好博客，就可以</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure>
<p>推送源文件到main分支</p>
<p><code>cd ..</code>在<code>YOUR_NAME.github.io</code>路径下执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m <span class="string">&quot;更新了XXX&quot;</span></span><br><span class="line">git push  <span class="comment">#会自动推送到src分支</span></span><br></pre></td></tr></table></figure>
<p>这样就实现了<strong>一个仓库管理源文件和网页文件</strong></p>
<h2 id="换电脑之后怎么恢复"><a href="#换电脑之后怎么恢复" class="headerlink" title="换电脑之后怎么恢复"></a>换电脑之后怎么恢复</h2><p>类似于安装博客，执行下面的步骤</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:seanleecn/seanleecn.github.io.git</span><br><span class="line"><span class="built_in">cd</span> seanleecn.github.io</span><br><span class="line">git checkout src <span class="comment">#切换到src分支</span></span><br><span class="line"><span class="built_in">cd</span> hexo</span><br><span class="line">npm install <span class="comment">#安装node_modules部件</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>简要说明一下，由于hexo默认生成了<code>.gitignore</code>文件，该文件会在备份源文件的过程中跳过<code>node_modules</code>和<code>.deploy_git</code>文件夹，也就是hexo的依赖包以及推送到main分支的文件都不会被备份。</p>
</blockquote>
<h1 id="主题配置的注意事项"><a href="#主题配置的注意事项" class="headerlink" title="主题配置的注意事项"></a>主题配置的注意事项</h1><ol>
<li><p>hexo5.0版本之后支持了npm安装主题，方便升级主题。使用<code>npm install hexo-theme-next</code>安装next主题。</p>
</li>
<li><p>由于采用npm安装，整个主题文件都在<code>node_modules</code>文件夹下面。为了直接使用升级(<code>npm install hexo-theme-next@latest</code>)，建议使用 Alternate Theme Config来配置，也就是不修改<code>node_modules</code>文件夹里面的东西，而是使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp node_modules/hexo-theme-next/_config.yml _config.next.yml</span><br></pre></td></tr></table></figure>
<p>把主题的配置文件都拷贝出来，修改<code>_config.next.yml</code>就可以实现配置主题。</p>
</li>
<li><p>_在Hexo/_config.yml修改theme关键字为next,<code>hexo s</code>看下效果</p>
</li>
</ol>
<h1 id="谷歌SEO优化"><a href="#谷歌SEO优化" class="headerlink" title="谷歌SEO优化"></a>谷歌SEO优化</h1><blockquote>
<p>维基百科：搜索引擎优化（英语：search engine optimization，缩写为SEO），是一种透过了解搜索引擎的运作规则来调整网站，以及提高目的网站在有关搜索引擎内排名的方式。</p>
</blockquote>
<p>SEO优化的目的就是为了让搜索引擎能够找到我们的网站，以本博客网站为例，在一开始搭建完成的时候，使用<code>site:seanleecn.github.io</code>在谷歌是检索不到我的网页的，因此需要做好SEO优化。</p>
<blockquote>
<p>由于本人没钱给买个人服务器给网站做CDN，而github域名又拒绝百度的爬虫访问，因此这里只涉及谷歌的SEO。</p>
</blockquote>
<ol>
<li><p>在<code>_config.yml</code>中修改<em>URL</em>为自己的网站域名</p>
</li>
<li><p>生成sitemap.xml</p>
 <figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br><span class="line">hexo clean</span><br><span class="line">hexo g <span class="comment">#在/public文件夹下面生成了sitemap.xml文件</span></span><br></pre></td></tr></table></figure></li>
<li><p>前往<a href="https://search.google.com/search-console/about">Google Search Console</a>填写域名，把选择HTML验证，并把验证内容填到<code>_config.next.yml</code>文件中。</p>
</li>
</ol>
]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/04/19/hello-world/</url>
    <content><![CDATA[<p>疫情影响下特殊的一年，研究生第一年在网课中匆匆收尾；却也因祸得福，得以和家人一起度过自己的生日。</p>
<p>今天是我23岁的生日，我的个人博客和父母出门吃晚饭前的一小时正式上线了！这是我给自己的生日礼物，希望能坚持记录自己的研究生生活。</p>
]]></content>
  </entry>
  <entry>
    <title>剑指Offer刷题日记-DFS</title>
    <url>/2020/08/18/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0-DFS/</url>
    <content><![CDATA[<p>记录<a href="https://leetcode-cn.com/problemset/lcof/">剑指Offer</a>中<code>DFS</code>相关的题目思路及解答。</p>
<p>文章会给出思路和代码，同时为了方便本地调试，还会提供相应的测试用例。</p>
<a id="more"></a>

<h1 id="剑指Offer12：矩阵中的路径"><a href="#剑指Offer12：矩阵中的路径" class="headerlink" title="剑指Offer12：矩阵中的路径"></a>剑指Offer12：矩阵中的路径</h1><p>题目：请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。</p>
<p>路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。</p>
<p>如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。</p>
<p>例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[[ &quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;e&quot; ],</span><br><span class="line"> [ &quot;s&quot;, &quot;f&quot;, &quot;c&quot;, &quot;s&quot; ],</span><br><span class="line"> [ &quot;a&quot;, &quot;d&quot;, &quot;e&quot;, &quot;e&quot; ]]</span><br></pre></td></tr></table></figure>
<p>但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。</p>
<h2 id="思路-DFS-回溯法"><a href="#思路-DFS-回溯法" class="headerlink" title="思路:DFS+回溯法"></a>思路:DFS+回溯法</h2><h3 id="show-me-code"><a href="#show-me-code" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义一个偏移数组,用于不同方向的搜索</span></span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="keyword">const</span> <span class="built_in">string</span> &amp;word, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;visited)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (index == word.size() - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> word[index] == board[i][j];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (word[index] == board[i][j])</span><br><span class="line">    &#123;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 4个方向都要DFS</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// k:0-&gt;3对应左 右 下 上</span></span><br><span class="line">            <span class="keyword">int</span> new_i = i + dir[k][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> new_j = j + dir[k][<span class="number">1</span>];</span><br><span class="line">            <span class="comment">// 探索的方向需要满足以下约束条件:</span></span><br><span class="line">            <span class="comment">// 1.非负;</span></span><br><span class="line">            <span class="comment">// 2.没有越界;</span></span><br><span class="line">            <span class="comment">// 3.没有访问过</span></span><br><span class="line">            <span class="keyword">if</span> (new_i &gt;= <span class="number">0</span> &amp;&amp; new_j &gt;= <span class="number">0</span> &amp;&amp; new_i &lt; board.size() &amp;&amp;</span><br><span class="line">                new_j &lt; board[<span class="number">0</span>].size() &amp;&amp; !visited[new_i][new_j])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (DFS(new_i, new_j, index + <span class="number">1</span>, board, word, visited))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; &amp;board, <span class="built_in">string</span> word)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = board.size();</span><br><span class="line">    <span class="keyword">int</span> column = board[<span class="number">0</span>].size();</span><br><span class="line">    <span class="comment">//!!!简介的二维vector初始化的方法!!!</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(row, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(column));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; column; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (DFS(i, j, <span class="number">0</span>, board, word, visited))</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **agrv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; mat1 = &#123;&#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;,</span><br><span class="line">                                 &#123;<span class="string">&#x27;S&#x27;</span>, <span class="string">&#x27;F&#x27;</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;S&#x27;</span>&#125;,</span><br><span class="line">                                 &#123;<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;D&#x27;</span>, <span class="string">&#x27;E&#x27;</span>, <span class="string">&#x27;E&#x27;</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">string</span> word1 = <span class="string">&quot;ABCCED&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; exist(mat1, word1) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//期望输出1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer13：机器人的运动范围"><a href="#剑指Offer13：机器人的运动范围" class="headerlink" title="剑指Offer13：机器人的运动范围"></a>剑指Offer13：机器人的运动范围</h1><p>题目：地上有一个m行n列的方格。一个机器人从坐标(0, 0)的格子开始移动，它每一次可以向左、右、上、下移动一格，但不能进入行坐标和列坐标的数位之和大于k的格子。</p>
<p>例如，当k为18时，机器人能够进入方格(35, 37)，因为3+5+3+7=18。但它不能进入方格(35, 38)，因为3+5+3+8=19。<br>请问该机器人能够到达多少个格子？</p>
<h2 id="思路-二维数组双重循环遍历-DFS"><a href="#思路-二维数组双重循环遍历-DFS" class="headerlink" title="思路:二维数组双重循环遍历+DFS"></a>思路:二维数组双重循环遍历+DFS</h2><h3 id="show-me-code-1"><a href="#show-me-code-1" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDigit</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += num % <span class="number">10</span>; <span class="comment">//个位数</span></span><br><span class="line">        num /= <span class="number">10</span>;       <span class="comment">//十位数</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; &amp;visited, <span class="keyword">int</span> &amp;count)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 数组越界</span></span><br><span class="line">    <span class="keyword">if</span> (row &lt; <span class="number">0</span> || row &gt;= m || col &lt; <span class="number">0</span> || col &gt;= n)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 坐标的数字和大于k</span></span><br><span class="line">    <span class="keyword">if</span> (getDigit(row) + getDigit(col) &gt; k)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 访问过了</span></span><br><span class="line">    <span class="keyword">if</span> (visited[row][col] == <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    visited[row][col] = <span class="literal">true</span>;</span><br><span class="line">    count++;</span><br><span class="line">    DFS(row + <span class="number">1</span>, col, m, n, k, visited, count); <span class="comment">//向下搜索</span></span><br><span class="line">    DFS(row, col + <span class="number">1</span>, m, n, k, visited, count); <span class="comment">//向右搜索</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//!!!二维数组初始化并定义大小和初值</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    DFS(<span class="number">0</span>, <span class="number">0</span>, m, n, k, visited, count);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; movingCount(<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//期望输出3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; movingCount(<span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//期望输出1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剑指Offer29：顺时针打印矩阵"><a href="#剑指Offer29：顺时针打印矩阵" class="headerlink" title="剑指Offer29：顺时针打印矩阵"></a>剑指Offer29：顺时针打印矩阵</h1><p>题目：输入一个矩阵，按照从外向里以顺时针的顺序依次打印出每一个数字。 </p>
<h2 id="思路-按圈模拟"><a href="#思路-按圈模拟" class="headerlink" title="思路:按圈模拟"></a>思路:按圈模拟</h2><ol>
<li><p>一圈有四个顶点(T,L)(T,R)(B,R)(B,L)</p>
</li>
<li><p>在一圈中的遍历顺序是:(T,L)-&gt;(T,R)-&gt;(B,R) *重点:判断L&lt;R &amp;&amp; T&lt;B* (B,R)-&gt;(B,L)-&gt;(T,L)</p>
</li>
<li><p>判断的作用是防止只剩一行或者一列的时候把这一行(列)重读添加</p>
</li>
<li><p>一圈结束后,TandL++,BandR–</p>
</li>
<li><p>判断所有圈都打印了:L&lt;=R &amp;&amp; T&lt;=B</p>
</li>
</ol>
<h3 id="show-me-code-2"><a href="#show-me-code-2" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (matrix.size() == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    int T(0), L(0), B(matrix.size() - 1), R(matrix[0].size() - 1); // 顶点坐标</span><br><span class="line">    <span class="comment">// 检测是否打印完了所有圈</span></span><br><span class="line">    <span class="keyword">while</span> (T &lt;= B &amp;&amp; L &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 左到右打印:(T,L)-&gt;(T,R)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = L; i &lt;= R; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(matrix[T][i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从上到下打印:(T,R)-&gt;(B,R)</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = T + <span class="number">1</span>; i &lt;= B; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(matrix[i][R]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 判断是否是单行或者单列</span></span><br><span class="line">        <span class="keyword">if</span> (L &lt; R &amp;&amp; T &lt; B)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 从右到左打印:(B,R)-&gt;(B,L)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = R - <span class="number">1</span>; i &gt;= L; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[B][i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 从下到上打印:(B,L)-&gt;(T,L)</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = B - <span class="number">1</span>; i &gt; T; i--)</span><br><span class="line">            &#123;</span><br><span class="line">                res.push_back(matrix[i][L]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 一圈打印完了,顶点坐标移动</span></span><br><span class="line">        T++;</span><br><span class="line">        L++;</span><br><span class="line">        B--;</span><br><span class="line">        R--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; mat&#123;&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>&#125;,</span><br><span class="line">                            &#123;<span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>&#125;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out = spiralOrder(mat);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;输出序列为: &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; out.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; out[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer38：字符串的排列"><a href="#剑指Offer38：字符串的排列" class="headerlink" title="剑指Offer38：字符串的排列"></a>剑指Offer38：字符串的排列</h1><p>题目：输入一个字符串，打印出该字符串中字符的所有排列。例如输入字符串abc，<br>则打印出由字符a、b、c所能排列出来的所有字符串abc、acb、bac、bca、cab和cba。</p>
<h2 id="思路-全排列问题-DFS-剪枝"><a href="#思路-全排列问题-DFS-剪枝" class="headerlink" title="思路:全排列问题+DFS+剪枝"></a>思路:全排列问题+DFS+剪枝</h2><p>第一个数字我们固定一个字符,有n个选择,第二位有n-1个选择…<br>直到只剩下一个选择的时候,把这一个排列push_back到vector中<br>当输入string存在重复的字符时,用set跳过这次选择 </p>
<h3 id="show-me-code-3"><a href="#show-me-code-3" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> pos, <span class="built_in">string</span> &amp;res_item, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; &amp;res)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件:pos指针移动到了最后</span></span><br><span class="line">    <span class="keyword">if</span> (pos == res_item.size() - <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res.push_back(res_item);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; uset; <span class="comment">// 每一次递归进入dfs函数,就维护一个set</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = pos; i &lt; res_item.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果set中已经有这个字母了,就跳过这一次循环</span></span><br><span class="line">        <span class="keyword">if</span> (uset.count(res_item[i]))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        uset.insert(res_item[i]);</span><br><span class="line">        <span class="comment">// 最巧妙的一步,# 剑指Offer书上也是这样处理的</span></span><br><span class="line">        <span class="comment">// 通过把i处的元素swap到pos的位置,来固定pos位置的元素(其实相对每次递归而言,pos就是string开头的位置)</span></span><br><span class="line">        swap(res_item[i], res_item[pos]);</span><br><span class="line">        dfs(pos + <span class="number">1</span>, res_item, res);</span><br><span class="line">        <span class="comment">// dfs返回之后,将string还原,不加这一步的话,对于输入abc的案例,输出会成为:</span></span><br><span class="line">        <span class="comment">// 正确输出:abc acb bac bca cba cab -&gt; 错误输出:abc acb cab cba abc acb</span></span><br><span class="line">        <span class="comment">// 即上一次的修改结果会影响到下一次</span></span><br><span class="line">        swap(res_item[i], res_item[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; <span class="title">permutation</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">    <span class="built_in">string</span> res_item = s; <span class="comment">// 不修改传入参数</span></span><br><span class="line">    dfs(<span class="number">0</span>, res_item, res);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-3"><a href="#测试用例-3" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res = permutation(s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// [&quot;abc&quot;,&quot;acb&quot;,&quot;bac&quot;,&quot;bca&quot;,&quot;cab&quot;,&quot;cba&quot;]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>DFS</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer刷题日记-位运算</title>
    <url>/2020/08/23/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0-%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<p>记录<a href="https://leetcode-cn.com/problemset/lcof/">剑指Offer</a>中<code>位运算</code>相关的题目思路及解答。</p>
<p>文章会给出思路和代码，同时为了方便本地调试，还会提供相应的测试用例。</p>
<a id="more"></a>

<h1 id="剑指Offer15：二进制中1的个数"><a href="#剑指Offer15：二进制中1的个数" class="headerlink" title="剑指Offer15：二进制中1的个数"></a>剑指Offer15：二进制中1的个数</h1><p>题目：请实现一个函数，输入一个整数，输出该数二进制表示中1的个数。<br>例如把9表示成二进制是1001，有2位是1。因此如果输入9，该函数输出2。</p>
<h3 id="show-me-code"><a href="#show-me-code" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">hammingWeight</span><span class="params">(<span class="keyword">uint32_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            count += <span class="number">1</span>;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="show-me-code-1"><a href="#show-me-code-1" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **agrv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hammingWeight(<span class="number">11</span>) &lt;&lt; <span class="built_in">endl</span>;         <span class="comment">//输入00000000000000000000000000001011,期望输出3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; hammingWeight(<span class="number">4294967293</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输入11111111111111111111111111111101,期望输出31</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer56（一）：数组中数字出现的次数"><a href="#剑指Offer56（一）：数组中数字出现的次数" class="headerlink" title="剑指Offer56（一）：数组中数字出现的次数"></a>剑指Offer56（一）：数组中数字出现的次数</h1><p>题目：一个整型数组里除了两个数字之外，其他的数字都出现了两次。<br>请写程序找出这两个只出现一次的数字。要求时间复杂度是O(n)，空间复杂度是O(1)。</p>
<h2 id="思路：异或运算"><a href="#思路：异或运算" class="headerlink" title="思路：异或运算"></a>思路：异或运算</h2><p>首先，拿hashmap统计次数的方法不行，不满足空间复杂度的要求<br>异或运算的性质：</p>
<ol>
<li>任何数 x 与 0 异或，结果为 x（恒等律）</li>
<li>任何数与自身异或，结果为 0（归零律）</li>
<li>异或运算还满足交换律与结合律</li>
</ol>
<p>以输入的测试vector为例子</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 ^ 2 ^ 10 ^ 4 ^ 1 ^ 4 ^ 3 ^ 3 &#x3D; 2 ^ 10 &#x3D; 0010 ^ 1010 &#x3D; 1000</span><br></pre></td></tr></table></figure>
<p>计算结果是<em>两个只出现一次的数</em>的二进制形式<br>为什么会出现1000这个结果？<br>原因是，当数组进行异或运算之后，最后的结果只和<em>两个只出现一次的数</em>有关，其他的数字都被归零了<br>如果这个数组里面的数字都出现了两次的，那么最后输出的结果一定是0<br>在测试案例中，因为存在2和10，导致在输出结果的1<em>右到左第四位</em>没有归零(1000)<br>下面是关键<br>我们把数组分成两个数组，分组依据是这个数的二进制形式在<em>右到左第四位</em>是0还是1<br>出现两次的数字<em>右到左第四位</em>一定相同，这样分别在这两个数组中进行异或运算，就能得到出现一次的数字</p>
<h3 id="show-me-code-2"><a href="#show-me-code-2" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">singleNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> exor = <span class="number">0</span>; <span class="comment">//异或结果</span></span><br><span class="line">    <span class="comment">// 得到两个只出现一次的数字的异或结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        exor = exor ^ i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到从右到左第一个1的位置</span></span><br><span class="line">    <span class="keyword">int</span> index_one = <span class="number">1</span>; <span class="comment">// 二进制形式是0001</span></span><br><span class="line">    <span class="keyword">while</span> (!(index_one &amp; exor))</span><br><span class="line">    &#123;</span><br><span class="line">        index_one &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 有两个0的数组</span></span><br><span class="line">    <span class="comment">// 根据index_one对数组进行分组处理</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &amp; index_one)</span><br><span class="line">        &#123;</span><br><span class="line">            res[<span class="number">0</span>] = res[<span class="number">0</span>] ^ i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res[<span class="number">1</span>] = res[<span class="number">1</span>] ^ i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="show-me-code-3"><a href="#show-me-code-3" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : singleNumbers(vec))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出：[2,10] 或 [10,2]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer56（一）：数组中数字出现的次数-II"><a href="#剑指Offer56（一）：数组中数字出现的次数-II" class="headerlink" title="剑指Offer56（一）：数组中数字出现的次数 II"></a>剑指Offer56（一）：数组中数字出现的次数 II</h1><p>题目：在一个数组 nums 中除一个数字只出现一次之外，其他数字都出现了三次。请找出那个只出现一次的数字</p>
<h2 id="思路1：hashmap"><a href="#思路1：hashmap" class="headerlink" title="思路1：hashmap"></a>思路1：hashmap</h2><h3 id="show-me-code-4"><a href="#show-me-code-4" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashmap;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        hashmap[i]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;::const_iterator itr;</span><br><span class="line">    <span class="keyword">for</span> (itr = hashmap.begin(); itr != hashmap.end();itr++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (itr-&gt;second == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> itr-&gt;first;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="思路2：位运算"><a href="#思路2：位运算" class="headerlink" title="思路2：位运算"></a>思路2：位运算</h2><p>把数组中每个数字的二进制形式的每一位都加起来，这样出现三次的数字每一位能够被3整除<br>当某一位不能整除，说明这个出现一次的数字在这里是1</p>
<h3 id="show-me-code-5"><a href="#show-me-code-5" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">bits</span><span class="params">(<span class="number">32</span>, <span class="number">0</span>)</span></span>; <span class="comment">//题干中给出int最大到2^31,所以需要一个32位的二进制</span></span><br><span class="line">    <span class="comment">// 每个数字转2进制并累加起来</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">31</span>; index &gt;= <span class="number">0</span>; index--)</span><br><span class="line">        &#123;</span><br><span class="line">            bits[index] += (num &amp; <span class="number">1</span>);</span><br><span class="line">            num &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 找出哪一位不能被3整除</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">31</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (bits[i] % <span class="number">3</span> != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res += <span class="built_in">pow</span>(<span class="number">2</span>, (<span class="number">31</span> - i));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">9</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">7</span>, <span class="number">9</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; singleNumber(vec) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer65：不用加减乘除做加法"><a href="#剑指Offer65：不用加减乘除做加法" class="headerlink" title="剑指Offer65：不用加减乘除做加法"></a>剑指Offer65：不用加减乘除做加法</h1><p>题目：写一个函数，求两个整数之和，要求在函数体内不得使用＋、－、×、÷四则运算符号。</p>
<h2 id="思路：位运算"><a href="#思路：位运算" class="headerlink" title="思路：位运算"></a>思路：位运算</h2><p>十进制的加法步骤(5+17)：</p>
<ol>
<li>不进位加法 12</li>
<li>计算进位，且进位的值是10</li>
<li>上面两步相加 22</li>
</ol>
<p>用二进制运算步骤(101+10001)</p>
<ol>
<li>不进位加法 10100</li>
<li>计算进位，且进位的值为10(二进制)</li>
<li>上面两步相加 10110(22)</li>
</ol>
<p>转换到位运算上</p>
<ol>
<li>不进位加法 == 异或运算</li>
<li>进位 == (a &amp; b) &lt;&lt; 1</li>
<li>两步相加 ==递归实现，直到没有进位</li>
</ol>
<h3 id="show-me-code-6"><a href="#show-me-code-6" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件:进位为0</span></span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> sum = a ^ b;</span><br><span class="line">    <span class="keyword">int</span> carry = (<span class="keyword">unsigned</span> <span class="keyword">int</span>)(a &amp; b) &lt;&lt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> add(sum, carry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; add(<span class="number">1</span>, <span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>位运算</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer刷题日记-动态规划</title>
    <url>/2020/08/21/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    <content><![CDATA[<p>记录<a href="https://leetcode-cn.com/problemset/lcof/">剑指Offer</a>中<code>动态规划</code>相关的题目思路及解答。</p>
<p>文章会给出思路和代码，同时为了方便本地调试，还会提供相应的测试用例。</p>
<a id="more"></a>

<h1 id="剑指Offer10：斐波那契数列"><a href="#剑指Offer10：斐波那契数列" class="headerlink" title="剑指Offer10：斐波那契数列"></a>剑指Offer10：斐波那契数列</h1><p>题目：写一个函数，输入n，求斐波那契（Fibonacci）数列的第n项。</p>
<p>斐波那契数列的定义如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">F(0) &#x3D; 0</span><br><span class="line">F(1) &#x3D; 1</span><br><span class="line">F(N) &#x3D; F(N - 1) + F(N - 2), 其中 N &gt; 1.</span><br></pre></td></tr></table></figure>
<h2 id="思路1-直接递归，O-2-N-复杂度"><a href="#思路1-直接递归，O-2-N-复杂度" class="headerlink" title="思路1: 直接递归，O(2^N)复杂度"></a>思路1: 直接递归，O(2^N)复杂度</h2><p>自顶向下计算,存在太多的重复中间项</p>
<h3 id="show-me-code"><a href="#show-me-code" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> res;</span><br><span class="line">        res = fib(n - <span class="number">1</span>) + fib(n - <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="思路2-循环实现"><a href="#思路2-循环实现" class="headerlink" title="思路2:循环实现"></a>思路2:循环实现</h2><p>自下向上(计算f(2),f(3)…直到f(n)) </p>
<h3 id="show-me-code-1"><a href="#show-me-code-1" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> fibN, fibN_minus1(<span class="number">1</span>), fibN_minus2(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        fibN = (fibN_minus1 + fibN_minus2) % <span class="number">1000000007</span>;</span><br><span class="line">        fibN_minus2 = fibN_minus1;</span><br><span class="line">        fibN_minus1 = fibN;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> fibN;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="思路3：带剪枝的递归"><a href="#思路3：带剪枝的递归" class="headerlink" title="思路3：带剪枝的递归"></a>思路3：带剪枝的递归</h2><p>自顶向下，从f(n)开始计算</p>
<h3 id="show-me-code-2"><a href="#show-me-code-2" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;memo, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (memo[n] != <span class="number">0</span>) <span class="comment">//如果已经计算过，直接返回就好了</span></span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    memo[n] = (helper(memo, n - <span class="number">1</span>) + helper(memo, n - <span class="number">2</span>)) % <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">return</span> memo[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fib</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>; <span class="comment">// 记录已经算过的数字，用于剪枝</span></span><br><span class="line">    <span class="keyword">return</span> helper(memo, n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **agrv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n=2: &quot;</span> &lt;&lt; fib(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// out:1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n=5: &quot;</span> &lt;&lt; fib(<span class="number">5</span>) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// out:5</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n=45: &quot;</span> &lt;&lt; fib(<span class="number">45</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// out:134903163</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer10-2：青蛙跳台阶问题"><a href="#剑指Offer10-2：青蛙跳台阶问题" class="headerlink" title="剑指Offer10-2：青蛙跳台阶问题"></a>剑指Offer10-2：青蛙跳台阶问题</h1><p>题目：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个n 级的台阶总共有多少种跳法。 </p>
<p>答案需要取模1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。 </p>
<h2 id="思路：动态规划"><a href="#思路：动态规划" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">n&#x3D;1 f(n)&#x3D;1</span><br><span class="line">n&#x3D;2 f(n)&#x3D;2</span><br><span class="line">最后一跳只有两种可能:跳一层或者跳两层,跳一层的情况即f(3-1),跳两层的情况即f(3-2)</span><br><span class="line">所以,f(3)&#x3D;f(1)+f(2)</span><br><span class="line">n&#x3D;N f(N)&#x3D;f(N-1)+f(N-2)</span><br><span class="line">即本题目也是一个斐波那契数列,只不过前2项不同</span><br></pre></td></tr></table></figure>
<h3 id="show-me-code-3"><a href="#show-me-code-3" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numWays</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> f, f_minus1(<span class="number">2</span>), f_minus2(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        f = (f_minus1 + f_minus2) % <span class="number">1000000007</span>;</span><br><span class="line">        f_minus2 = f_minus1;</span><br><span class="line">        f_minus1 = f;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n=2: &quot;</span> &lt;&lt; numWays(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n=7: &quot;</span> &lt;&lt; numWays(<span class="number">7</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n=0: &quot;</span> &lt;&lt; numWays(<span class="number">0</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer14-1：剪绳子"><a href="#剑指Offer14-1：剪绳子" class="headerlink" title="剑指Offer14-1：剪绳子"></a>剑指Offer14-1：剪绳子</h1><p>题目：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m-1] 。 </p>
<p>请问k[0]<em>k[1]</em>…*k[m-1] 可能的最大乘积是多少？</p>
<p>例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<h1 id="剑指Offer14-2：剪绳子"><a href="#剑指Offer14-2：剪绳子" class="headerlink" title="剑指Offer14-2：剪绳子"></a>剑指Offer14-2：剪绳子</h1><p>题目：给你一根长度为 n 的绳子，请把绳子剪成整数长度的 m 段（m、n都是整数，n&gt;1并且m&gt;1），每段绳子的长度记为 k[0],k[1]…k[m - 1] 。</p>
<p>请问 k[0]<em>k[1]</em>…*k[m - 1] 可能的最大乘积是多少？<br>例如，当绳子的长度是8时，我们把它剪成长度分别为2、3、3的三段，此时得到的最大乘积是18。</p>
<p>答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1</p>
<h2 id="思路14-1-动态规划"><a href="#思路14-1-动态规划" class="headerlink" title="思路14_1:动态规划"></a>思路14_1:动态规划</h2><p>定义f(n)为长度为n的绳子剪成m段乘积的最大值</p>
<p>自底向上计算 </p>
<h3 id="show-me-code-4"><a href="#show-me-code-4" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//长度n&lt;=3做特殊处理</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>; <span class="comment">//1&lt;2</span></span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>; <span class="comment">//2&lt;3</span></span><br><span class="line">    <span class="comment">// maxs[n]表示长度为n的绳子得到的结果</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxs</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// n=1,2,3的时候,如果再分割的话,结果比不分割还小,所以当绳子到1,2,3长度之后就不剪了,返回的值就是1,2,3</span></span><br><span class="line">    maxs[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    maxs[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    maxs[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> max_i, i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">4</span>; i &lt;= n; i++)</span><br><span class="line">    &#123; <span class="comment">//自下而上计算最大值,并存在maxs中</span></span><br><span class="line">        max_i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt;= i / <span class="number">2</span>; j++)</span><br><span class="line">        &#123; <span class="comment">//i/2为了减少计算次数</span></span><br><span class="line">            <span class="keyword">int</span> product_max = maxs[j] * maxs[i - j];</span><br><span class="line">            <span class="keyword">if</span> (product_max &gt; max_i)</span><br><span class="line">            &#123;</span><br><span class="line">                max_i = product_max;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        maxs[i] = max_i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxs[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="思路2-贪婪"><a href="#思路2-贪婪" class="headerlink" title="思路2: 贪婪"></a>思路2: 贪婪</h2><p>第二题比第一题多了大数求余步骤</p>
<p>当n&gt;=5,3(n-3)&gt;=2(n-2)</p>
<p>当n=4时,最大的情况是2*2=4,即可以不用剪 </p>
<h3 id="show-me-code-5"><a href="#show-me-code-5" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">cuttingRope</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">3</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">long</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">4</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res *= <span class="number">3</span>;</span><br><span class="line">        res = res % <span class="number">1000000007</span>;</span><br><span class="line">        n -= <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res * n % <span class="number">1000000007</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cuttingRope(<span class="number">8</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//期望输出18</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cuttingRope(<span class="number">2</span>) &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">//期望输出1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; cuttingRope(<span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//期望输出36</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer42：连续子数组的最大和"><a href="#剑指Offer42：连续子数组的最大和" class="headerlink" title="剑指Offer42：连续子数组的最大和"></a>剑指Offer42：连续子数组的最大和</h1><p>题目：输入一个整型数组，数组里有正数也有负数。数组中一个或连续的多个整数组成一个子数组。求所有子数组的和的最大值。要求时间复杂度为O(n)。</p>
<h2 id="思路：动态规划！"><a href="#思路：动态规划！" class="headerlink" title="思路：动态规划！"></a>思路：动态规划！</h2><ol>
<li><p>用dp[i]表示以i为nums[i]为结尾的连续子数组的最大和</p>
</li>
<li><p>状态转移方程</p>
</li>
</ol>
<p>当dp[i-1] &lt; 0，说明不如直接用nums[i]作为dp[i]</p>
<p>当dp[i-1] &gt; 0，说明nums[i] + dp[i-1]就是dp[i]</p>
<ol start="3">
<li>返回dp数组的最大值 </li>
</ol>
<h3 id="show-me-code-6"><a href="#show-me-code-6" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(nums.size(), nums[<span class="number">0</span>])</span></span>; <span class="comment">//初始化为nums[0]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (dp[i - <span class="number">1</span>] &lt;= <span class="number">0</span>)</span><br><span class="line">            dp[i] = nums[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i] = nums[i] + dp[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *max_element(dp.begin(), dp.end()); <span class="comment">// #include &lt;algorithm&gt;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试用例-3"><a href="#测试用例-3" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">-2</span>, <span class="number">1</span>, <span class="number">-3</span>, <span class="number">4</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">-5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxSubArray(nums) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//期望输出6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer46：把数字翻译成字符串"><a href="#剑指Offer46：把数字翻译成字符串" class="headerlink" title="剑指Offer46：把数字翻译成字符串"></a>剑指Offer46：把数字翻译成字符串</h1><p>题目：给定一个数字，我们按照如下规则把它翻译为字符串：0翻译成”a”，1翻译成”b”，……，11翻译成”l”，……，25翻译成”z”。</p>
<p>一个数字可能有多个翻译。例如12258有5种不同的翻译，它们分别是”bccfi”、”bwfi”、”bczi”、”mcfi”和”mzi”。</p>
<p>请编程实现一个函数用来计算一个数字有多少种不同的翻译方法。</p>
<h2 id="思路：动态规划-1"><a href="#思路：动态规划-1" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><p>这题的递推公式有点难以理解，以12258为例子</p>
<p>dp[i]表示长度为i的数字有几种翻译方式</p>
<ol>
<li><p>最后一个数字单独翻译，根据<em>分步乘法</em>（先翻译前i-1位，再翻译最后1位，而最后1位只有一种翻译方法）得到dp[i] = dp[i-1] * 1</p>
</li>
<li><p>最后两个数字可以组合翻译，根据<em>分类加法</em>（最后两位组合翻译+最后两位单独翻译）得到dp[i] = dp[i-1] * 1 + dp[i-2] * 1<br>因此可以得到</p>
</li>
</ol>
<p>dp[i] = dp[i-1]            10*(i-1)+i不在[10,25]的范围,不能被翻译</p>
<p>dp[i] = dp[i-1] + dp[i-2]  10*(i-1)+i在[10,25]的范围，能被翻译</p>
<h3 id="show-me-code-7"><a href="#show-me-code-7" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">translateNum</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> str = to_string(num);</span><br><span class="line">    <span class="keyword">int</span> len = str.length();</span><br><span class="line">    <span class="comment">// 初始化dp</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(len + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; len + <span class="number">1</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i - <span class="number">2</span>] == <span class="string">&#x27;1&#x27;</span> || (str[i - <span class="number">2</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; str[i - <span class="number">1</span>] &lt;= <span class="string">&#x27;5&#x27;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[len];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试用例-4"><a href="#测试用例-4" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; translateNum(<span class="number">12258</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer47：礼物的最大价值"><a href="#剑指Offer47：礼物的最大价值" class="headerlink" title="剑指Offer47：礼物的最大价值"></a>剑指Offer47：礼物的最大价值</h1><p>题目：在一个m×n的棋盘的每一格都放有一个礼物，每个礼物都有一定的价值（价值大于0）。</p>
<p>你可以从棋盘的左上角开始拿格子里的礼物，并每次向右或者向下移动一格直到到达棋盘的右下角。</p>
<p>给定一个棋盘及其上面的礼物，请计算你最多能拿到多少价值的礼物？</p>
<h2 id="思路：动态规划-2"><a href="#思路：动态规划-2" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><ol>
<li><p>dp数组表示某一个格子的最大价值</p>
</li>
<li><p>状态转移方程 </p>
<p>dp[i][j] = max(dp[i - 1][j], dp[i][j - 1]) + grid[i][j];</p>
</li>
</ol>
<h3 id="show-me-code-8"><a href="#show-me-code-8" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;grid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> row = grid.size();</span><br><span class="line">    <span class="keyword">int</span> col = grid[<span class="number">0</span>].size();</span><br><span class="line">    <span class="comment">// 由于动态转移方程中涉及到了[i-1]的索引，因此将dp数组扩大一行一列，防止索引越界</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(row + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(col + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">// dp[i][j] 表示grid[0][0] -&gt; grid[i-1][j-1]的最大价值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= row; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= col; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][j] = max(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]) + grid[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 注意索引</span></span><br><span class="line">    <span class="keyword">return</span> dp[row][col];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试用例-5"><a href="#测试用例-5" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; grid = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                                &#123;<span class="number">1</span>, <span class="number">5</span>, <span class="number">1</span>&#125;,</span><br><span class="line">                                &#123;<span class="number">4</span>, <span class="number">2</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxValue(grid) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 12 ,路径为 1→3→5→2→1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer49：丑数"><a href="#剑指Offer49：丑数" class="headerlink" title="剑指Offer49：丑数"></a>剑指Offer49：丑数</h1><p>题目：我们把只包含因子2、3和5的数称作丑数（Ugly Number）。求按从小到大的顺序的第n个丑数。</p>
<p>习惯上我们把1当做第一个丑数。 </p>
<h2 id="思路：动态规划-3"><a href="#思路：动态规划-3" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><ol>
<li>任意的丑数<em>2、</em>3、*5都是丑数（2、3、5都是质数）</li>
<li>使用一个dp数组保存全部的丑数，dp[0] = 1</li>
<li>已知一个丑数dp[n]，则dp[n+1]应满足min(dp[a]*2, dp[b]*3, dp[c]*5)，其中a、b、c是以2、3、5为因子的下标</li>
<li>关于dp的理解：根据特点1可知，对于一个丑数数列，分别<em>2、</em>3、*5得到三个数列A、B、C都是丑数数列。因此需要把这三个数列整合成一个，整合的方法就是建立三个指针，每次比较这三个指针中那个值得数最小，然后指针后移一位</li>
</ol>
<h3 id="show-me-code-9"><a href="#show-me-code-9" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nthUglyNumber</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// dp初始化</span></span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 三个下标初始化</span></span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>, c = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> n2 = dp[a] * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> n3 = dp[b] * <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">int</span> n5 = dp[c] * <span class="number">5</span>;</span><br><span class="line">        dp[i] = min(min(n2, n3), n5);</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == n2)</span><br><span class="line">            a++;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == n3)</span><br><span class="line">            b++;</span><br><span class="line">        <span class="keyword">if</span> (dp[i] == n5)</span><br><span class="line">            c++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试用例-6"><a href="#测试用例-6" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; nthUglyNumber(<span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//12</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指-Offer-60-n个骰子的点数"><a href="#剑指-Offer-60-n个骰子的点数" class="headerlink" title="剑指 Offer 60. n个骰子的点数"></a>剑指 Offer 60. n个骰子的点数</h1><p>题目：把n个骰子扔在地上，所有骰子朝上一面的点数之和为s。输入n，打印出s的所有可能的值出现的概率。</p>
<p>你需要用一个浮点数数组返回答案，其中第 i 个元素代表这 n 个骰子所能掷出的点数集合中第 i 小的那个的概率。</p>
<h2 id="思路：动态规划-4"><a href="#思路：动态规划-4" class="headerlink" title="思路：动态规划"></a>思路：动态规划</h2><ol>
<li>n个骰子，朝上的面点数之和s范围是[n,6n]，因此返回数组长度为6n-n+1</li>
<li>根据概率知识，结果s出现的概率表示为 s出现的次数/6^n</li>
<li>动态转移方程 dp[n][s] = dp[n-1][s-k] k属于[1,6]<br> 举例：投3个骰子得到7的概率，可以表示为投2个骰子得到2，3，4，5，6的概率</li>
</ol>
<h3 id="show-me-code-10"><a href="#show-me-code-10" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">dicesProbability</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; <span class="title">res</span><span class="params">(n * <span class="number">6</span> - n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">6</span> * n + <span class="number">1</span>, <span class="number">0</span>)); <span class="comment">// 将全部值初始化为 0</span></span><br><span class="line">    <span class="keyword">int</span> row = n + <span class="number">1</span>, col = <span class="number">6</span> * n + <span class="number">1</span>;                         <span class="comment">//col ==&gt; [0,6n] 共6n+1列</span></span><br><span class="line">    <span class="comment">// 初始化第一个骰子</span></span><br><span class="line">    <span class="comment">// dp[1][1]=1 代表一个骰子点数和为 1 的情况有一种</span></span><br><span class="line">    <span class="comment">// dp[1][2]=1 代表一个骰子点数和为 2 的情况有一种</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">6</span>; i++)</span><br><span class="line">        dp[<span class="number">1</span>][i] = <span class="number">1</span>; <span class="comment">//因为只有一个骰子时，点数和为1,2,3,4,5,6的情况都各只有一种</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; row; i++)</span><br><span class="line">    &#123; <span class="comment">//从2颗骰子开始计算</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; col; j++)</span><br><span class="line">        &#123; <span class="comment">//j就是点数之和s,是从i开始的，代表i个骰子点数之和的最小值为i</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= <span class="number">6</span>; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//dp[i][j]表示 i个骰子点数之和为j的数量有多少？</span></span><br><span class="line">                <span class="comment">//答：当第i个骰子点数为k时，那么前i-1个骰子点数和必须等于j-k，则k+(j-k)=j;</span></span><br><span class="line">                <span class="comment">//把所有dp[i-1][j-k]的数量加起来(k∈[1,6])，就等于dp[i][j]的数量了</span></span><br><span class="line">                <span class="keyword">if</span> (j - k &gt; <span class="number">0</span>)</span><br><span class="line">                    dp[i][j] += dp[i - <span class="number">1</span>][j - k];</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">double</span> denominator = <span class="built_in">pow</span>(<span class="number">6.0</span>, n); <span class="comment">// 分母</span></span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = n; k &lt;= <span class="number">6</span> * n; k++)</span><br><span class="line">        <span class="comment">//计算概率 放入答案</span></span><br><span class="line">        res[index++] = dp[n][k] / denominator; <span class="comment">//n个骰子，共可以产生6^n种</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试用例-7"><a href="#测试用例-7" class="headerlink" title="测试用例"></a>测试用例</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">double</span>&gt; res = dicesProbability(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : res)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer63：股票的最大利润"><a href="#剑指Offer63：股票的最大利润" class="headerlink" title="剑指Offer63：股票的最大利润"></a>剑指Offer63：股票的最大利润</h1><p>题目：假设把某股票的价格按照时间先后顺序存储在数组中，请问买卖交易该股票可能获得的利润是多少？</p>
<h2 id="思路1：贪心"><a href="#思路1：贪心" class="headerlink" title="思路1：贪心"></a>思路1：贪心</h2><p>股票的奥义:最低点买入，最高点卖出<br>一轮遍历，每次更新最低值和收益</p>
<h3 id="show-me-code-11"><a href="#show-me-code-11" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 没有卖出的可能</span></span><br><span class="line">    <span class="keyword">if</span> (prices.size() &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : prices)</span><br><span class="line">    &#123;</span><br><span class="line">        minPrice = min(minPrice, i);</span><br><span class="line">        profit = max(profit, i - minPrice);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="思路2：动态规划"><a href="#思路2：动态规划" class="headerlink" title="思路2：动态规划"></a>思路2：动态规划</h2><ol>
<li>dp[i]表示第i天的最大利润</li>
<li>初始化dp[o] = 0</li>
<li>状态转移 dp[i] = max(dp[i-1] , price[i] - minPrice[0:i-1])<br>第i天的最大收益 = 第i-1天的最大收益 以及 [1:i-1]天中最低价买入，当天卖出 这两种情况中较大的值  </li>
<li>对比思路1，状态转移中dp[i]只和dp[i-1]相关，因此可以用一个变量profit表示，这样就和思路1一样的形式了 </li>
</ol>
<h3 id="show-me-code-12"><a href="#show-me-code-12" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;prices)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> day = prices.size();</span><br><span class="line">    <span class="keyword">if</span> (day &lt; <span class="number">2</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(day, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> minPrice = prices[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; day; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        dp[i] = max(dp[i - <span class="number">1</span>], prices[i] - minPrice);</span><br><span class="line">        minPrice = min(minPrice, prices[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[day - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="测试用例-8"><a href="#测试用例-8" class="headerlink" title="测试用例"></a>测试用例</h2><pre><code class="c++">int main()
&#123;
    vector&lt;int&gt; prices1 = &#123;7, 1, 5, 3, 6, 4&#125;;
    cout &lt;&lt; maxProfit(prices1) &lt;&lt; endl; // 5
    vector&lt;int&gt; prices2 = &#123;7, 6, 4, 3, 1&#125;;
    cout &lt;&lt; maxProfit(prices2) &lt;&lt; endl; // 0
&#125;</code></pre>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>动态规划</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer刷题日记-数组</title>
    <url>/2020/08/30/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0-%E5%AD%97%E7%AC%A6%E4%B8%B2/</url>
    <content><![CDATA[<p>记录<a href="https://leetcode-cn.com/problemset/lcof/">剑指Offer</a>中<code>字符串</code>相关的题目思路及解答。</p>
<p>文章会给出思路和代码，同时为了方便本地调试，还会提供相应的测试用例。</p>
<a id="more"></a>

<h1 id="剑指Offer50：第一个只出现一次的字符"><a href="#剑指Offer50：第一个只出现一次的字符" class="headerlink" title="剑指Offer50：第一个只出现一次的字符"></a>剑指Offer50：第一个只出现一次的字符</h1><p>题目：在字符串 s 中找出第一个只出现一次的字符。如果没有，返回一个单空格。 s 只包含小写字母。</p>
<h2 id="思路：哈希表"><a href="#思路：哈希表" class="headerlink" title="思路：哈希表"></a>思路：哈希表</h2><h3 id="show-me-code"><a href="#show-me-code" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">firstUniqChar</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!s.length())</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; umap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s)</span><br><span class="line">    &#123;</span><br><span class="line">        umap[c] += <span class="number">1</span>; <span class="comment">//语法糖</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历s找到次数为1</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (umap[c] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; firstUniqChar(<span class="string">&quot;abaccdeff&quot;</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// b</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; firstUniqChar(<span class="string">&quot;&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;          <span class="comment">// &quot; &quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer58（一）：翻转单词顺序"><a href="#剑指Offer58（一）：翻转单词顺序" class="headerlink" title="剑指Offer58（一）：翻转单词顺序"></a>剑指Offer58（一）：翻转单词顺序</h1><p>题目：输入一个英文句子，翻转句子中单词的顺序，但单词内字符的顺序不变。为简单起见，标点符号和普通字母一样处理。<br>例如输入字符串”I am a student. “，则输出”student. a am I”。</p>
<h2 id="思路1：利用字符流的特性"><a href="#思路1：利用字符流的特性" class="headerlink" title="思路1：利用字符流的特性"></a>思路1：利用字符流的特性</h2><p>primer p77介绍到，字符流会忽略开头的空白</p>
<h3 id="show-me-code-1"><a href="#show-me-code-1" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">iss</span><span class="params">(s)</span></span>;</span><br><span class="line">    <span class="built_in">string</span> res, word;</span><br><span class="line">    <span class="comment">// 字符流会忽略空格得到单词</span></span><br><span class="line">    <span class="keyword">while</span> (iss &gt;&gt; word)</span><br><span class="line">    &#123;</span><br><span class="line">        res = word + <span class="string">&#x27; &#x27;</span> + res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// res最后面会有个空格需要删除</span></span><br><span class="line">    <span class="comment">// 当输入为&quot; &quot;的时候，res为空，因此用erase为越界</span></span><br><span class="line">    <span class="keyword">return</span> res.substr(<span class="number">0</span>, res.size() - <span class="number">1</span>);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="思路2：双指针"><a href="#思路2：双指针" class="headerlink" title="思路2：双指针"></a>思路2：双指针</h2><ol>
<li>两个指针从最右边开始左移</li>
<li>遇到字符左指针移动，找到单词的开始和结束位置</li>
<li>建立一个res来拼接单词</li>
</ol>
<h3 id="show-me-code-2"><a href="#show-me-code-2" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">reverseWords</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = s.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = s.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">string</span> res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 跳过空格</span></span><br><span class="line">        <span class="keyword">while</span> (s[left] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            --left;</span><br><span class="line">            --right;</span><br><span class="line">            <span class="comment">// 防止本层循环中s[left]越界</span></span><br><span class="line">            <span class="keyword">if</span> (left &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止下面计算s[left]越界</span></span><br><span class="line">        <span class="keyword">if</span> (left &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 上面循环结束，左右指针都指向单词的最后一个字母</span></span><br><span class="line">        <span class="keyword">while</span> (s[left] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            --left;</span><br><span class="line">            <span class="keyword">if</span> (left &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 此时left指向单词的前一个字母,right指向单词的最后一个字母</span></span><br><span class="line">        res += s.substr(left + <span class="number">1</span>, right - left);</span><br><span class="line">        res.append(<span class="string">&quot; &quot;</span>);</span><br><span class="line">        right = left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 删除最后一个空格</span></span><br><span class="line">    <span class="keyword">return</span> res.substr(<span class="number">0</span>, res.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; reverseWords(<span class="string">&quot;  hello world!  &quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出 : &quot;world! hello&quot;</span></span><br><span class="line">    <span class="comment">// 解释 : 输入字符串可以在前面或者后面包含多余的空格，但是反转后的字符不能包括。</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; reverseWords(<span class="string">&quot;the sky is blue&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// blue is sky the</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer58（二）：左旋转字符串"><a href="#剑指Offer58（二）：左旋转字符串" class="headerlink" title="剑指Offer58（二）：左旋转字符串"></a>剑指Offer58（二）：左旋转字符串</h1><p>题目：字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。</p>
<p>比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<h2 id="思路1：substr一行秒杀！"><a href="#思路1：substr一行秒杀！" class="headerlink" title="思路1：substr一行秒杀！"></a>思路1：substr一行秒杀！</h2><h3 id="show-me-code-3"><a href="#show-me-code-3" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.substr(n) + s.substr(<span class="number">0</span>, n);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="思路2：遍历string"><a href="#思路2：遍历string" class="headerlink" title="思路2：遍历string"></a>思路2：遍历string</h2><h3 id="show-me-code-4"><a href="#show-me-code-4" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">reverseLeftWords</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">res</span><span class="params">(<span class="string">&quot;&quot;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &lt; s.size(); i++)</span><br><span class="line">        res += s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        res += s[i];</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; reverseLeftWords(<span class="string">&quot;lrloseumgh&quot;</span>, <span class="number">6</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 输出 : &quot;umghlrlose&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>字符串</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer刷题日记-实现库函数</title>
    <url>/2020/08/18/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0-%E5%AE%9E%E7%8E%B0%E5%BA%93%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<p>记录<a href="https://leetcode-cn.com/problemset/lcof/">剑指Offer</a>中<code>实现库函数</code>相关的题目思路及解答。</p>
<p>文章会给出思路和代码，同时为了方便本地调试，还会提供相应的测试用例。</p>
<a id="more"></a>

<h1 id="剑指Offer16：数值的整数次方"><a href="#剑指Offer16：数值的整数次方" class="headerlink" title="剑指Offer16：数值的整数次方"></a>剑指Offer16：数值的整数次方</h1><p>题目：实现函数double Power(double base, int exponent)，求base的exponent次方。<br>不得使用库函数，同时不需要考虑大数问题。</p>
<h2 id="思路：递归法"><a href="#思路：递归法" class="headerlink" title="思路：递归法"></a>思路：递归法</h2><h3 id="show-me-code"><a href="#show-me-code" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">power</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> res = power(x, n &gt;&gt; <span class="number">1</span>); <span class="comment">//右移一位,相当于除以2</span></span><br><span class="line">    <span class="comment">//判断指数是基数还是偶数,用位与代替%</span></span><br><span class="line">    <span class="keyword">if</span> (n &amp; <span class="number">0x1</span> == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        res = res * res * x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        res = res * res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">long</span> num = n;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> power(x, num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> power(<span class="number">1</span> / x, -num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路2：二分法"><a href="#思路2：二分法" class="headerlink" title="思路2：二分法"></a>思路2：二分法</h2><p>设res=1,则x^n=x^n*res=(x^2)^(n/2)<em>res=…=(x^n)^1</em>res </p>
<h3 id="show-me-code-1"><a href="#show-me-code-1" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">myPow</span><span class="params">(<span class="keyword">double</span> x, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x == <span class="number">1</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">double</span> res = <span class="number">1.0</span>;</span><br><span class="line">    <span class="keyword">long</span> num = n;<span class="comment">//int变量取负号可能越界</span></span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        x = <span class="number">1</span> / x;</span><br><span class="line">        num = -num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (num &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num % <span class="number">2</span> == <span class="number">1</span>) res *= x;</span><br><span class="line">        x *= x;</span><br><span class="line">        num /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **agrv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myPow(<span class="number">2</span>, <span class="number">10</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myPow(<span class="number">2.1</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; myPow(<span class="number">2</span>, <span class="number">-2</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剑指Offer67：求1-2-…-n"><a href="#剑指Offer67：求1-2-…-n" class="headerlink" title="剑指Offer67：求1+2+…+n"></a>剑指Offer67：求1+2+…+n</h1><p>求 1+2+…+n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<h2 id="思路1：计算内存（太秀了）"><a href="#思路1：计算内存（太秀了）" class="headerlink" title="思路1：计算内存（太秀了）"></a>思路1：计算内存（太秀了）</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1+2+3+...+n</span><br><span class="line">&#x3D;(1+n)*n&#x2F;2</span><br><span class="line">&#x3D;sizeof(bool a[n][n+1])&#x2F;2</span><br><span class="line">&#x3D;sizeof(bool a[n][n+1])&gt;&gt;1</span><br></pre></td></tr></table></figure>
<h3 id="show-me-code-2"><a href="#show-me-code-2" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> a[n][n + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">sizeof</span>(a) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="思路2：逻辑运算的短路特性"><a href="#思路2：逻辑运算的短路特性" class="headerlink" title="思路2：逻辑运算的短路特性"></a>思路2：逻辑运算的短路特性</h2><ol>
<li>A &amp;&amp; B</li>
<li>A 为 true，则计算并返回表达式 B 的 bool 值</li>
<li>A 为 false，则直接返回 false</li>
</ol>
<h3 id="show-me-code-3"><a href="#show-me-code-3" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n &amp;&amp; (n += sumNums(n - <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; sumNums(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//6</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>实现库函数</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer刷题日记-栈和队列</title>
    <url>/2020/08/19/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
    <content><![CDATA[<p>记录<a href="https://leetcode-cn.com/problemset/lcof/">剑指Offer</a>中<code>栈和队列</code>相关的题目思路及解答。</p>
<p>文章会给出思路和代码，同时为了方便本地调试，还会提供相应的测试用例。</p>
<a id="more"></a>

<h1 id="剑指Offer9：用两个栈实现一个队列"><a href="#剑指Offer9：用两个栈实现一个队列" class="headerlink" title="剑指Offer9：用两个栈实现一个队列"></a>剑指Offer9：用两个栈实现一个队列</h1><p>题目：用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。</p>
<p>若队列中没有元素，deleteHead 操作返回 -1 </p>
<h3 id="show-me-code"><a href="#show-me-code" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    CQueue() &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123; s1.push(value); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//如果s2是空的,将s1的元素pop之后push进s2,并弹出s2栈顶元素</span></span><br><span class="line">        <span class="keyword">if</span> (s2.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s1.empty())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">//此时队列为空</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">while</span> (!s1.empty())</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> &amp;elemnet = s1.top(); <span class="comment">// top返回栈顶元素的引用</span></span><br><span class="line">                    s1.pop();</span><br><span class="line">                    s2.push(elemnet);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> &amp;top = s2.top();</span><br><span class="line">        s2.pop();</span><br><span class="line">        <span class="keyword">return</span> top;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s1; <span class="comment">//对s1入栈操作,即入队列</span></span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; s2; <span class="comment">//对s2出栈操作,即出队列</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **agrv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    CQueue *obj = <span class="keyword">new</span> CQueue();</span><br><span class="line">    obj-&gt;appendTail(<span class="number">1</span>);</span><br><span class="line">    obj-&gt;appendTail(<span class="number">2</span>);</span><br><span class="line">    obj-&gt;appendTail(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">int</span> param_1 = obj-&gt;deleteHead();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; param_1 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    obj-&gt;appendTail(<span class="number">4</span>);</span><br><span class="line">    <span class="keyword">int</span> param_2 = obj-&gt;deleteHead();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; param_2 &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">delete</span> obj;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剑指Offer30-包含min函数的栈"><a href="#剑指Offer30-包含min函数的栈" class="headerlink" title="剑指Offer30:包含min函数的栈"></a>剑指Offer30:包含min函数的栈</h1><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，<br>调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><ol>
<li>只用单个变量记录最小元素,当最小元素出栈后无法再找到最小的元素</li>
<li>需要用到辅助栈,辅助栈用来保存插入元素后这一时刻,原栈中的最小元素</li>
<li>即原栈有元素入栈时,只有是最小元素时才能进入辅助栈,否则辅助栈中的栈顶元素重复入栈</li>
</ol>
<h3 id="show-me-code-1"><a href="#show-me-code-1" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    * initialize your data structure here. </span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk, stk_min;</span><br><span class="line">    MinStack()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stk.push(x); <span class="comment">// 原栈</span></span><br><span class="line">        <span class="comment">// 辅助栈入栈流程</span></span><br><span class="line">        <span class="keyword">if</span> (stk_min.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            stk_min.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (x &gt;= stk_min.top())</span><br><span class="line">        &#123;</span><br><span class="line">            stk_min.push(stk_min.top());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            stk_min.push(x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        stk.pop();</span><br><span class="line">        stk_min.pop();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk.top();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stk_min.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MinStack *obj = <span class="keyword">new</span> MinStack();</span><br><span class="line">    obj-&gt;push(<span class="number">3</span>);</span><br><span class="line">    obj-&gt;push(<span class="number">4</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj-&gt;top() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj-&gt;min() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer31-栈的压入、弹出序列"><a href="#剑指Offer31-栈的压入、弹出序列" class="headerlink" title="剑指Offer31:栈的压入、弹出序列"></a>剑指Offer31:栈的压入、弹出序列</h1><p>输入两个整数序列，第一个序列表示栈的压入顺序，请判断第二个序列是否为该栈的弹出顺序。<br>假设压入栈的所有数字均不相等。</p>
<p>例如，序列 {1,2,3,4,5} 是某栈的压栈序列，<br>序列 {4,5,3,2,1} 是该压栈序列对应的一个弹出序列，<br>但 {4,3,5,1,2} 就不可能是该压栈序列的弹出序列。</p>
<blockquote>
<p>题意理解:入栈顺序不意味着要一次全入完,可以部分入栈再出栈再入栈</p>
</blockquote>
<h2 id="思路-一个元素入栈后-检查栈顶的元素-如果满足弹出队列-出栈-否则继续插入"><a href="#思路-一个元素入栈后-检查栈顶的元素-如果满足弹出队列-出栈-否则继续插入" class="headerlink" title="思路:一个元素入栈后,检查栈顶的元素,如果满足弹出队列,出栈;否则继续插入"></a>思路:一个元素入栈后,检查栈顶的元素,如果满足弹出队列,出栈;否则继续插入</h2><h3 id="show-me-code-2"><a href="#show-me-code-2" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">validateStackSequences</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;pushed, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;popped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="keyword">int</span> pop_idx = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> push_idx = <span class="number">0</span>; push_idx &lt; pushed.size(); push_idx++)</span><br><span class="line">    &#123;</span><br><span class="line">        stk.push(pushed[push_idx]);</span><br><span class="line">        <span class="keyword">while</span> (!stk.empty() &amp;&amp; popped[pop_idx] == stk.top())</span><br><span class="line">        &#123; <span class="comment">// 出错点2:stk需要非空才能pop</span></span><br><span class="line">            stk.pop();</span><br><span class="line">            <span class="keyword">if</span> (pop_idx == popped.size() - <span class="number">1</span>)</span><br><span class="line">            &#123; <span class="comment">// 出错点1:防止pop_idx数组越界</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            pop_idx++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> stk.empty();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; push = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pop1 = &#123;<span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pop2 = &#123;<span class="number">4</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    validateStackSequences(push, pop1) ? <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; <span class="built_in">endl</span> : <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    validateStackSequences(push, pop2) ? <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; <span class="built_in">endl</span> : <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer59（一）：滑动窗口的最大值"><a href="#剑指Offer59（一）：滑动窗口的最大值" class="headerlink" title="剑指Offer59（一）：滑动窗口的最大值"></a>剑指Offer59（一）：滑动窗口的最大值</h1><p>题目：给定一个数组和滑动窗口的大小，请找出所有滑动窗口里的最大值。</p>
<h2 id="思路1：双端队列元素下标"><a href="#思路1：双端队列元素下标" class="headerlink" title="思路1：双端队列元素下标"></a>思路1：双端队列元素下标</h2><p>如何保证队列中的front是最大?生活中我们使用末位淘汰制度，这里也是一个道理</p>
<p>新来的元素从max_index先前检查，当新来元素比尾部的大，就把当前尾部的元素弹出，这样队列中头部的元素一定是最大的<br>由于是一个滑动窗口，因此当窗口离开最大元素的位置时，要弹出头部元素</p>
<h3 id="show-me-code-3"><a href="#show-me-code-3" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.empty())</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; max_index; <span class="comment">//保存的是最大值的下标</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 队列初始化，队列初始话之后，front是最大的元素的下标</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 新来的比back大，说明back不可能是窗口中的最大值，pop_back</span></span><br><span class="line">        <span class="keyword">while</span> (!max_index.empty() &amp;&amp; nums[i] &gt;= nums[max_index.back()])</span><br><span class="line">            max_index.pop_back();</span><br><span class="line">        <span class="comment">// 新来的进入队列</span></span><br><span class="line">        max_index.push_back(i);</span><br><span class="line">    &#125;</span><br><span class="line">    res.push_back(nums[max_index.front()]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化之后，窗口从k开始滑动</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = k; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// 新来的比back大，back肯定不是最大值，pop_back</span></span><br><span class="line">        <span class="keyword">while</span> (!max_index.empty() &amp;&amp; nums[i] &gt;= nums[max_index.back()])</span><br><span class="line">            max_index.pop_back();</span><br><span class="line">        <span class="comment">// 当窗口离开front位置时，front已经没用了，因此要pop_front</span></span><br><span class="line">        <span class="keyword">if</span> (!max_index.empty() &amp;&amp; max_index.front() &lt;= (i - k))</span><br><span class="line">            max_index.pop_front();</span><br><span class="line">        <span class="comment">// 新来的进入队列</span></span><br><span class="line">        max_index.push_back(i);</span><br><span class="line">        res.push_back(nums[max_index.front()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-3"><a href="#测试用例-3" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in = &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">-1</span>, <span class="number">-3</span>, <span class="number">5</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="comment">// 由于输入参数为vector的左值引用，因此不能直接拿表达式&#123;&#125;传参数进去</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out = maxSlidingWindow(in, <span class="number">3</span>);</span><br><span class="line">    <span class="comment">// 输出:[ 3, 3, 5, 5, 6, 7 ]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : out)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer59（二）：队列的最大值"><a href="#剑指Offer59（二）：队列的最大值" class="headerlink" title="剑指Offer59（二）：队列的最大值"></a>剑指Offer59（二）：队列的最大值</h1><p>请定义一个队列并实现函数 max_value 得到队列里的最大值，要求函数max_value、push_back 和 pop_front 的均摊时间复杂度都是O(1)。<br>若队列为空，pop_front 和 max_value 需要返回 -1</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>这题和上一题很像，datal队列维护全部的数据，max双端队列用末位淘汰法维护最大的元素</p>
<h3 id="show-me-code-4"><a href="#show-me-code-4" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MaxQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line">    <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; max;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MaxQueue()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">max_value</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (max.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> max.front();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push_back</span><span class="params">(<span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        data.push(value);</span><br><span class="line">        <span class="comment">// 从max队列的尾端开始，进行末位淘汰制度</span></span><br><span class="line">        <span class="keyword">while</span> (!max.empty() &amp;&amp; value &gt;= max.back())</span><br><span class="line">            max.pop_back();</span><br><span class="line">        max.push_back(value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop_front</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (data.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">int</span> front = data.front();</span><br><span class="line">        <span class="comment">// 最大元素弹出的话，max队列也要更新</span></span><br><span class="line">        <span class="keyword">if</span> (front == max.front())</span><br><span class="line">            max.pop_front();</span><br><span class="line">        data.pop();</span><br><span class="line">        <span class="keyword">return</span> front;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-4"><a href="#测试用例-4" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    MaxQueue *obj = <span class="keyword">new</span> MaxQueue();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj-&gt;max_value() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// -1</span></span><br><span class="line">    obj-&gt;push_back(<span class="number">1</span>);</span><br><span class="line">    obj-&gt;push_back(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj-&gt;pop_front() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//2</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; obj-&gt;max_value() &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>栈和队列</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer刷题日记-滑动窗口</title>
    <url>/2020/08/25/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/</url>
    <content><![CDATA[<p>记录<a href="https://leetcode-cn.com/problemset/lcof/">剑指Offer</a>中<code>滑动窗口</code>相关的题目思路及解答。</p>
<p>文章会给出思路和代码，同时为了方便本地调试，还会提供相应的测试用例。</p>
<a id="more"></a>

<h1 id="剑指Offer48：最长不含重复字符的子字符串"><a href="#剑指Offer48：最长不含重复字符的子字符串" class="headerlink" title="剑指Offer48：最长不含重复字符的子字符串"></a>剑指Offer48：最长不含重复字符的子字符串</h1><p>题目：请从字符串中找出一个最长的不包含重复字符的子字符串，计算该最长子字符串的长度。<br>假设字符串中只包含从’a’到’z’的字符。</p>
<h2 id="思路：滑动窗口"><a href="#思路：滑动窗口" class="headerlink" title="思路：滑动窗口"></a>思路：滑动窗口</h2><ol>
<li>初始化两个指针left 和 right，都指向字符串最左边 </li>
<li>right 指针遍历字符串，并将所指的字符添加到hash表</li>
<li>每添加一个元素进hash，检查是否存在相同元素。若存在，left指针右移，直到hash表中没有重复元素</li>
<li>res更新当前滑动窗口中的字符串长度</li>
</ol>
<h3 id="show-me-code"><a href="#show-me-code" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; hash;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; right &lt; s.size(); right++)</span><br><span class="line">    &#123;</span><br><span class="line">        hash[s[right]]++;</span><br><span class="line">        <span class="comment">// 检查重复元素并消除重复元素</span></span><br><span class="line">        <span class="keyword">while</span> (hash[s[right]] &gt; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            hash[s[left]]--;</span><br><span class="line">            ++left;</span><br><span class="line">        &#125;</span><br><span class="line">        res = max(res, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; lengthOfLongestSubstring(<span class="string">&quot;abcabcbb&quot;</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; lengthOfLongestSubstring(<span class="string">&quot;bbbbb&quot;</span>) &lt;&lt; <span class="built_in">endl</span>;    <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer57（一）：和为s的两个数字"><a href="#剑指Offer57（一）：和为s的两个数字" class="headerlink" title="剑指Offer57（一）：和为s的两个数字"></a>剑指Offer57（一）：和为s的两个数字</h1><p>题目：输入一个递增排序的数组和一个数字s，在数组中查找两个数，使得它们的和正好是s。如果有多对数字的和等于s，输出任意一对即可。 </p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>首先，双循环会超时，且题目给出了是递增数列，所以采用双指针<br>建立两个指针，分别指向数组的头和尾</p>
<h3 id="show-me-code-1"><a href="#show-me-code-1" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> j = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 注意这个判断条件</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] + nums[j] &gt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[i] + nums[j] &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res[<span class="number">0</span>] = nums[i];</span><br><span class="line">            res[<span class="number">1</span>] = nums[j];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test1 = &#123;<span class="number">10</span>, <span class="number">26</span>, <span class="number">30</span>, <span class="number">31</span>, <span class="number">47</span>, <span class="number">60</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : twoSum(test1, <span class="number">40</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 10 30</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer57（二）：为s的连续正数序列"><a href="#剑指Offer57（二）：为s的连续正数序列" class="headerlink" title="剑指Offer57（二）：为s的连续正数序列"></a>剑指Offer57（二）：为s的连续正数序列</h1><p>题目：输入一个正数s，打印出所有和为s的连续正数序列（至少含有两个数）。<br>序列内的数字由小到大排列，不同序列按照首个数字从小到大排列。</p>
<h2 id="思路：滑动窗口-1"><a href="#思路：滑动窗口-1" class="headerlink" title="思路：滑动窗口"></a>思路：滑动窗口</h2><h3 id="show-me-code-2"><a href="#show-me-code-2" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findContinuousSequence(<span class="keyword">int</span> target)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">    <span class="comment">// i为窗口的左端点，j为窗口的右端点，sum为窗口内元素之和</span></span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (sum == target)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = i; k &lt;= j; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                ans.push_back(k);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(ans);</span><br><span class="line">            ans.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素和太小，j右移一位</span></span><br><span class="line">        <span class="keyword">if</span> (sum &lt; target)</span><br><span class="line">        &#123;</span><br><span class="line">            ++j;</span><br><span class="line">            sum += j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 元素和太大，i右移一位</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum -= i;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> arg, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; out1 = findContinuousSequence(<span class="number">9</span>);</span><br><span class="line">    <span class="comment">// [ [ 2, 3, 4 ], [ 4, 5 ] ]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> vec : out1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : vec)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; out2 = findContinuousSequence(<span class="number">15</span>);</span><br><span class="line">    <span class="comment">// [[1,2,3,4,5],[4,5,6],[7,8]]</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> vec : out2)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> i : vec)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>滑动窗口</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer刷题日记-链表</title>
    <url>/2020/08/20/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0-%E9%93%BE%E8%A1%A8/</url>
    <content><![CDATA[<p>记录<a href="https://leetcode-cn.com/problemset/lcof/">剑指Offer</a>中<code>链表</code>相关的题目思路及解答。</p>
<p>文章会给出思路和代码，同时为了方便本地调试，还会提供相应的测试用例。</p>
<a id="more"></a>

<p>如果要在本地调试，需要先包含下面的头文件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 本头文件定义了剑指Offer中链表题常用的链表结构体和链表构造函数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MYLISTNODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYLISTNODE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode *next;</span><br><span class="line">    ListNode(<span class="keyword">int</span> x) : val(x), next(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; head-&gt;val &lt;&lt; <span class="string">&quot;-&gt;&quot;</span>;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer6：从尾到头打印链表"><a href="#剑指Offer6：从尾到头打印链表" class="headerlink" title="剑指Offer6：从尾到头打印链表"></a>剑指Offer6：从尾到头打印链表</h1><p>题目：输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<h2 id="思路1：使用栈先入后出的特性，实现反向打印"><a href="#思路1：使用栈先入后出的特性，实现反向打印" class="headerlink" title="思路1：使用栈先入后出的特性，实现反向打印"></a>思路1：使用栈先入后出的特性，实现反向打印</h2><h3 id="show-me-code"><a href="#show-me-code" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; stk;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="comment">//入栈</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        stk.push(head-&gt;val);</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//出栈</span></span><br><span class="line">    <span class="keyword">while</span> (!stk.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        vec.push_back(stk.top()); <span class="comment">//栈顶元素进数组</span></span><br><span class="line">        stk.pop();                <span class="comment">//出栈</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> vec;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="思路2：递归的方法，递归本质就是一个栈结构，但是其时间空间复杂度较差"><a href="#思路2：递归的方法，递归本质就是一个栈结构，但是其时间空间复杂度较差" class="headerlink" title="思路2：递归的方法，递归本质就是一个栈结构，但是其时间空间复杂度较差"></a>思路2：递归的方法，递归本质就是一个栈结构，但是其时间空间复杂度较差</h2><h3 id="show-me-code-1"><a href="#show-me-code-1" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec_recursive;</span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>)</span><br><span class="line">        <span class="keyword">return</span> vec_recursive;</span><br><span class="line">    reversePrint(head-&gt;next);</span><br><span class="line">    vec_recursive.push_back(head-&gt;val);</span><br><span class="line">    <span class="keyword">return</span> vec_recursive;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//输入[1,3,2]</span></span><br><span class="line">    ListNode *node1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    ListNode *node2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">    ListNode *node3 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">    node1-&gt;next = node3;</span><br><span class="line">    node3-&gt;next = node2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;before: &quot;</span>;</span><br><span class="line">    printList(node1);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;after(recursive): &quot;</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; revList = reversePrint(node1);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator iter;</span><br><span class="line">    <span class="keyword">for</span> (iter = revList.begin(); iter != revList.end(); iter++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *iter &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer18：删除链表的节点"><a href="#剑指Offer18：删除链表的节点" class="headerlink" title="剑指Offer18：删除链表的节点"></a>剑指Offer18：删除链表的节点</h1><p>题目：给定单向链表的头指针和一个要删除的节点的值，定义一个函数删除该节点。<br>返回删除后的链表的头节点。<br>注意：此题对比原题有改动 </p>
<h2 id="思路1-单指针扫描法"><a href="#思路1-单指针扫描法" class="headerlink" title="思路1:单指针扫描法"></a>思路1:单指针扫描法</h2><h3 id="show-me-code-2"><a href="#show-me-code-2" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">deleteNode</span><span class="params">(ListNode* head, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//第一个元素就是要删除的</span></span><br><span class="line">    <span class="keyword">if</span> (head-&gt;val == val) &#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* node = head;<span class="comment">//保存头指针,不然while之后找不到头指针</span></span><br><span class="line">    <span class="keyword">while</span> (head-&gt;next-&gt;val != val) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = head-&gt;next-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="思路2-递归删除法"><a href="#思路2-递归删除法" class="headerlink" title="思路2:递归删除法"></a>思路2:递归删除法</h2><h3 id="show-me-code-3"><a href="#show-me-code-3" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">deleteNode</span><span class="params">(ListNode *head, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head-&gt;val == val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    head-&gt;next = deleteNode(head-&gt;next, val);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *node4 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">    ListNode *node5 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">    ListNode *node1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    ListNode *node9 = <span class="keyword">new</span> ListNode(<span class="number">9</span>);</span><br><span class="line">    node4-&gt;next = node5;</span><br><span class="line">    node5-&gt;next = node1;</span><br><span class="line">    node1-&gt;next = node9;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;原始链表: &quot;</span>;</span><br><span class="line">    printList(node4);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;删除: &quot;</span>;</span><br><span class="line">    printList(deleteNode(node4, <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer22：链表中倒数第k个结点"><a href="#剑指Offer22：链表中倒数第k个结点" class="headerlink" title="剑指Offer22：链表中倒数第k个结点"></a>剑指Offer22：链表中倒数第k个结点</h1><p>题目：输入一个链表，输出该链表中倒数第k个结点。为了符合大多数人的习惯，<br>本题从1开始计数，即链表的尾结点是倒数第1个结点。例如一个链表有6个结点，<br>从头结点开始它们的值依次是1、2、3、4、5、6。这个链表的倒数第3个结点是<br>值为4的结点。 </p>
<h2 id="思路1-由于是单向链表-不能回溯-因此两次遍历"><a href="#思路1-由于是单向链表-不能回溯-因此两次遍历" class="headerlink" title="思路1:由于是单向链表,不能回溯.因此两次遍历"></a>思路1:由于是单向链表,不能回溯.因此两次遍历</h2><p>第一次遍历确定链表长度,第二次遍历次数为长度-k </p>
<h3 id="show-me-code-4"><a href="#show-me-code-4" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getKthFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">    ListNode* <span class="built_in">list</span> = head;  <span class="comment">//保存头指针</span></span><br><span class="line">    <span class="keyword">while</span> (head != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        head = head-&gt;next;</span><br><span class="line">        length++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">list</span> != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == length - k + <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line">        cnt++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="思路2-快慢指针-一个指针先走k步-保证双指针的距离为k"><a href="#思路2-快慢指针-一个指针先走k步-保证双指针的距离为k" class="headerlink" title="思路2:快慢指针,一个指针先走k步,保证双指针的距离为k"></a>思路2:快慢指针,一个指针先走k步,保证双指针的距离为k</h2><p>当先走的指针指向NULL时,后走的指针指向倒数k个结点 </p>
<h3 id="show-me-code-5"><a href="#show-me-code-5" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getKthFromEnd</span><span class="params">(ListNode *head, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> | k == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    ListNode *slow = head;</span><br><span class="line">    ListNode *quick = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> cnt_k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt_k &lt; k)</span><br><span class="line">    &#123;</span><br><span class="line">        quick = quick-&gt;next;</span><br><span class="line">        cnt_k++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (quick != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        quick = quick-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *node1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    ListNode *node2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">    ListNode *node3 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">    ListNode *node4 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">    ListNode *node5 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line">    node2-&gt;next = node3;</span><br><span class="line">    node3-&gt;next = node4;</span><br><span class="line">    node4-&gt;next = node5;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;原始链表: &quot;</span>;</span><br><span class="line">    printList(node1);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;倒数第k个结点:&quot;</span>;</span><br><span class="line">    ListNode *endk = getKthFromEnd(node1, <span class="number">1</span>);</span><br><span class="line">    printList(endk);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剑指Offer24：反转链表"><a href="#剑指Offer24：反转链表" class="headerlink" title="剑指Offer24：反转链表"></a>剑指Offer24：反转链表</h1><p>题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。</p>
<h2 id="思路1-剑指Offer书上-定义三个指针"><a href="#思路1-剑指Offer书上-定义三个指针" class="headerlink" title="思路1:# 剑指Offer书上,定义三个指针"></a>思路1:# 剑指Offer书上,定义三个指针</h2><h3 id="show-me-code-6"><a href="#show-me-code-6" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* res = <span class="literal">NULL</span>;  <span class="comment">//返回值</span></span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    ListNode* pre = <span class="literal">NULL</span>;</span><br><span class="line">    ListNode* next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        next = cur-&gt;next;  <span class="comment">//把cur-&gt;next存起来,下一步就要断开链表了</span></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            res = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        cur-&gt;next = pre;  <span class="comment">//反转</span></span><br><span class="line">        pre = cur;        <span class="comment">//右移一次</span></span><br><span class="line">        cur = next;       <span class="comment">//右移一次</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="思路2-递归"><a href="#思路2-递归" class="headerlink" title="思路2:递归"></a>思路2:递归</h2><p><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/ru-guo-ni-kan-wan-ping-lun-he-ti-jie-huan-you-wen-/">https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof/solution/ru-guo-ni-kan-wan-ping-lun-he-ti-jie-huan-you-wen-/</a></p>
<h3 id="show-me-code-7"><a href="#show-me-code-7" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">reverseList</span><span class="params">(ListNode *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 递归的终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span> | head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *cur = reverseList(head-&gt;next);</span><br><span class="line">    head-&gt;next-&gt;next = head;</span><br><span class="line">    head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> cur;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试用例-3"><a href="#测试用例-3" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *node1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    ListNode *node2 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">    ListNode *node3 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">    ListNode *node4 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">    ListNode *node5 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line">    node2-&gt;next = node3;</span><br><span class="line">    node3-&gt;next = node4;</span><br><span class="line">    node4-&gt;next = node5;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;原始链表: &quot;</span>;</span><br><span class="line">    printList(node1);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;反转链表: &quot;</span>;</span><br><span class="line">    printList(reverseList(node1));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer25：合并两个排序的链表"><a href="#剑指Offer25：合并两个排序的链表" class="headerlink" title="剑指Offer25：合并两个排序的链表"></a>剑指Offer25：合并两个排序的链表</h1><p>题目：输入两个递增排序的链表，合并这两个链表并使新链表中的结点仍然是按照递增排序的。</p>
<h2 id="思路-迭代"><a href="#思路-迭代" class="headerlink" title="思路:迭代"></a>思路:迭代</h2><p>由于一开始合并链表中无头节点,需要建立一个辅助结点dum<br>由于是有序链表,当一个链表遍历完了,只要把剩下的链表接到后面就好 </p>
<h3 id="show-me-code-8"><a href="#show-me-code-8" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">mergeTwoLists</span><span class="params">(ListNode *l1, ListNode *l2)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">NULL</span> || l2 == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> l1 == <span class="literal">NULL</span> ? l2 : l1;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode *dum = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">    ListNode *cur = dum;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">NULL</span> &amp;&amp; l2 != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &gt;= l2-&gt;val)</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    cur-&gt;next = l1 == <span class="literal">NULL</span> ? l2 : l1; <span class="comment">// 把剩下的接上去</span></span><br><span class="line">    <span class="keyword">return</span> dum-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-4"><a href="#测试用例-4" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ListNode *n11 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    ListNode *n12 = <span class="keyword">new</span> ListNode(<span class="number">2</span>);</span><br><span class="line">    ListNode *n14 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">    ListNode *n21 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    ListNode *n23 = <span class="keyword">new</span> ListNode(<span class="number">3</span>);</span><br><span class="line">    ListNode *n24 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">    n11-&gt;next = n12;</span><br><span class="line">    n12-&gt;next = n14;</span><br><span class="line">    n21-&gt;next = n23;</span><br><span class="line">    n23-&gt;next = n24;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;链表1: &quot;</span>;</span><br><span class="line">    printList(n11);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;链表2: &quot;</span>;</span><br><span class="line">    printList(n21);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;合并后:&quot;</span>;</span><br><span class="line">    printList(mergeTwoLists(n11, n21));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer35-复杂链表的复制"><a href="#剑指Offer35-复杂链表的复制" class="headerlink" title="剑指Offer35. 复杂链表的复制"></a>剑指Offer35. 复杂链表的复制</h1><p>请实现 copyRandomList 函数，复制一个复杂链表。</p>
<p>在复杂链表中，每个节点除了有一个 next 指针指向下一个节点，还有一个 random 指针指向链表中的任意节点或者 null。</p>
<h3 id="show-me-code-9"><a href="#show-me-code-9" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    Node *next;</span><br><span class="line">    Node *random;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> _val)</span><br><span class="line">    &#123;</span><br><span class="line">        val = _val;</span><br><span class="line">        next = <span class="literal">NULL</span>;</span><br><span class="line">        random = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="思路1"><a href="#思路1" class="headerlink" title="思路1:"></a>思路1:</h2><p>random输出的是到head的距离</p>
<p>第一轮遍历,先根据next把新链表连接起来,并建一个哈希表</p>
<p>再根据哈希表,确定新链表random的连接关系 </p>
<h3 id="show-me-code-10"><a href="#show-me-code-10" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">copyRandomList</span><span class="params">(Node* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;Node*, Node*&gt; match;  <span class="comment">//哈希表</span></span><br><span class="line">    Node* pos = head;                   <span class="comment">// 原链表的索引指针</span></span><br><span class="line">    Node* res_head = <span class="keyword">new</span> Node(head-&gt;val);</span><br><span class="line">    Node* res_pos = res_head;  <span class="comment">// 新链表的索引指针</span></span><br><span class="line">    <span class="comment">// 第一轮遍历先根据next建好链表</span></span><br><span class="line">    <span class="keyword">while</span> (pos) &#123;</span><br><span class="line">        match[pos] = res_pos;  <span class="comment">// 哈希表中存新旧链表的索引指针</span></span><br><span class="line">        <span class="keyword">if</span> (!pos-&gt;next) &#123;</span><br><span class="line">            res_pos-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res_pos-&gt;next = <span class="keyword">new</span> Node(pos-&gt;next-&gt;val);</span><br><span class="line">        &#125;</span><br><span class="line">        pos = pos-&gt;next;</span><br><span class="line">        res_pos = res_pos-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第一轮遍历结束,pos和res_pos指向链表末端,需要重新指向头部</span></span><br><span class="line">    pos = head;</span><br><span class="line">    res_pos = res_head;</span><br><span class="line">    <span class="comment">// 第二轮遍历,根据哈希表,连接random</span></span><br><span class="line">    <span class="keyword">while</span> (pos) &#123;</span><br><span class="line">        res_pos-&gt;random = match[pos-&gt;random];</span><br><span class="line">        res_pos = res_pos-&gt;next;</span><br><span class="line">        pos = pos-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res_head;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="思路2"><a href="#思路2" class="headerlink" title="思路2:"></a>思路2:</h2><ol>
<li>复制节点,复制节点插入在原始节点后面如:a-&gt;a’-&gt;b-&gt;b’</li>
<li>复制random指针,复制后的random指向原random的next</li>
<li>链表的偶数项就是复制后的链表 </li>
<li><h3 id="show-me-code-11"><a href="#show-me-code-11" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyNode</span><span class="params">(Node *head)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyRandom</span><span class="params">(Node *head)</span></span>;</span><br><span class="line"><span class="function">Node *<span class="title">getCopy</span><span class="params">(Node *head)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">copyRandomList</span><span class="params">(Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!head)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    copyNode(head);</span><br><span class="line">    copyRandom(head);</span><br><span class="line">    <span class="keyword">return</span> getCopy(head);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1.复制节点,复制节点插入在原始节点后面如:a-&gt;a&#x27;-&gt;b-&gt;b&#x27;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyNode</span><span class="params">(Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *pos = head;</span><br><span class="line">    <span class="keyword">while</span> (pos)</span><br><span class="line">    &#123;</span><br><span class="line">        Node *copy = <span class="keyword">new</span> Node(pos-&gt;val);</span><br><span class="line">        <span class="comment">// 链表插入节点,先接上,再断开</span></span><br><span class="line">        copy-&gt;next = pos-&gt;next;</span><br><span class="line">        pos-&gt;next = copy;</span><br><span class="line">        <span class="comment">// 插入节点后,pos指针移动两个单位</span></span><br><span class="line">        pos = pos-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 2.复制random指针,复制后的random指向原random的next</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">copyRandom</span><span class="params">(Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *pos = head;</span><br><span class="line">    <span class="keyword">while</span> (pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 如果a-&gt;random存在,那么a&#x27;-&gt;random就是a-&gt;random-&gt;next</span></span><br><span class="line">        <span class="keyword">if</span> (pos-&gt;random)</span><br><span class="line">        &#123;</span><br><span class="line">            pos-&gt;next-&gt;random = pos-&gt;random-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            pos-&gt;next-&gt;random = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        pos = pos-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 3.链表的偶数项就是复制后的链表</span></span><br><span class="line"><span class="function">Node *<span class="title">getCopy</span><span class="params">(Node *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *pos = head;</span><br><span class="line">    Node *copy = pos-&gt;next;</span><br><span class="line">    Node *res = copy;</span><br><span class="line">    <span class="keyword">while</span> (pos)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 下面这里的指针移动要注意画图理解,关注当pos移动到NULL之后的操作</span></span><br><span class="line">        pos-&gt;next = copy-&gt;next;</span><br><span class="line">        pos = pos-&gt;next;</span><br><span class="line">        <span class="comment">// 下面很巧妙,可以用a-&gt;a&#x27;-&gt;b-&gt;b&#x27;-&gt;NULL理画图理解</span></span><br><span class="line">        <span class="keyword">if</span> (pos)</span><br><span class="line">        &#123;</span><br><span class="line">            copy-&gt;next = pos-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        copy = copy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-5"><a href="#测试用例-5" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *head = <span class="keyword">new</span> Node(<span class="number">7</span>);</span><br><span class="line">    Node *two = <span class="keyword">new</span> Node(<span class="number">13</span>);</span><br><span class="line">    Node *three = <span class="keyword">new</span> Node(<span class="number">11</span>);</span><br><span class="line">    Node *four = <span class="keyword">new</span> Node(<span class="number">10</span>);</span><br><span class="line">    Node *five = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">    head-&gt;next = two;</span><br><span class="line">    two-&gt;next = three;</span><br><span class="line">    three-&gt;next = four;</span><br><span class="line">    four-&gt;next = five;</span><br><span class="line">    five-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    head-&gt;random = <span class="literal">NULL</span>;</span><br><span class="line">    two-&gt;random = head;</span><br><span class="line">    three-&gt;random = five;</span><br><span class="line">    four-&gt;random = three;</span><br><span class="line">    five-&gt;random = head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 本题目不写输出函数,因为输出部分其实就涉及到了复制的思路</span></span><br><span class="line">    <span class="comment">// 直接在调试里面看</span></span><br><span class="line"></span><br><span class="line">    Node *res = copyRandomList(head);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer52：两个链表的第一个公共结点"><a href="#剑指Offer52：两个链表的第一个公共结点" class="headerlink" title="剑指Offer52：两个链表的第一个公共结点"></a>剑指Offer52：两个链表的第一个公共结点</h1>题目：输入两个链表，找出它们的第一个公共结点。</li>
</ol>
<h2 id="思路1-哈希表"><a href="#思路1-哈希表" class="headerlink" title="思路1:哈希表"></a>思路1:哈希表</h2><h3 id="show-me-code-12"><a href="#show-me-code-12" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!headA || !headB)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;ListNode *, <span class="keyword">int</span>&gt; nodes;</span><br><span class="line">    ListNode *n1 = headA;</span><br><span class="line">    ListNode *n2 = headB;</span><br><span class="line">    <span class="keyword">while</span> (n1) &#123;</span><br><span class="line">        ++nodes[n1];</span><br><span class="line">        n1 = n1-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历一次链表2，当哈希表中有相同元素返回</span></span><br><span class="line">    <span class="keyword">while</span> (n2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nodes[n2])   </span><br><span class="line">            <span class="keyword">return</span> n2;</span><br><span class="line">        n2 = n2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路2-1"><a href="#思路2-1" class="headerlink" title="思路2"></a>思路2</h2><ol>
<li>headA的长度可以表示为 A+same</li>
<li>headB的长度可以表示为 B+same</li>
<li>因此采用两个指针分别遍历 A+same+B 和 B+same+A</li>
<li>最后停下来的地方就是重复的节点 </li>
</ol>
<h3 id="show-me-code-13"><a href="#show-me-code-13" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!headA || !headB)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode *ptrA = headA, *ptrB = headB;</span><br><span class="line">    <span class="keyword">while</span> (ptrA != ptrB)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ptrA)</span><br><span class="line">            ptrA = ptrA-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="comment">// headA走到头，从headB开始走</span></span><br><span class="line">            ptrA = headB;</span><br><span class="line">        <span class="keyword">if</span> (ptrB)</span><br><span class="line">            ptrB = ptrB-&gt;next;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            ptrB = headA;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ptrA;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-6"><a href="#测试用例-6" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **agrv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 这道题目的输入要注意，不是两条链表，可以理解是一个分叉链表</span></span><br><span class="line">    <span class="comment">// 各自独立的节点</span></span><br><span class="line">    ListNode *headA = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">    ListNode *a1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    ListNode *headB = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">    ListNode *b0 = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">    ListNode *b1 = <span class="keyword">new</span> ListNode(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 下面是重复的节点</span></span><br><span class="line">    ListNode *n8 = <span class="keyword">new</span> ListNode(<span class="number">8</span>);</span><br><span class="line">    ListNode *n4 = <span class="keyword">new</span> ListNode(<span class="number">4</span>);</span><br><span class="line">    ListNode *n5 = <span class="keyword">new</span> ListNode(<span class="number">5</span>);</span><br><span class="line">    <span class="comment">// 链接重复部分</span></span><br><span class="line">    n8-&gt;next = n4;</span><br><span class="line">    n4-&gt;next = n5;</span><br><span class="line"></span><br><span class="line">    headA-&gt;next = a1;</span><br><span class="line">    a1-&gt;next = n8;</span><br><span class="line">    printList(headA);</span><br><span class="line">    headB-&gt;next = b0;</span><br><span class="line">    b0-&gt;next = b1;</span><br><span class="line">    b1-&gt;next = n8;</span><br><span class="line">    printList(headB);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; getIntersectionNode(headA, headB)-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>记一次samba服务器漏洞升级维护</title>
    <url>/2021/01/11/%E8%AE%B0%E4%B8%80%E6%AC%A1Samba%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8D%87%E7%BA%A7%E7%BB%B4%E6%8A%A4/</url>
    <content><![CDATA[<p>实验室服务器太久没维护，samba的一个漏洞被机房封IP了，记录一下修复的过程。</p>
<p>服务器系统为CentOS 7.8，是实验室的文件存储中心。修复的难度主要来源于每行代码要检查N遍才敢回车，生怕自己不小心删库，然后快进到退学提桶跑路。</p>
<blockquote>
<p>后续：机房禁止samba服务，改用FTP了。。。</p>
</blockquote>
<a id="more"></a>

<h2 id="查看当前安装的Samba服务器版本"><a href="#查看当前安装的Samba服务器版本" class="headerlink" title="查看当前安装的Samba服务器版本"></a>查看当前安装的Samba服务器版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smbstatus</span><br></pre></td></tr></table></figure>
<p>当前是4.10.13</p>
<h2 id="查看yum源里面的Samba版本"><a href="#查看yum源里面的Samba版本" class="headerlink" title="查看yum源里面的Samba版本"></a>查看yum源里面的Samba版本</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum list | grep samba</span><br><span class="line"><span class="comment"># 输出 samba.x86_64                                3:4.10.13-1.el7            @copr:copr.fedorainfracloud.org:sergiomb:SambaAD</span></span><br></pre></td></tr></table></figure>
<p>发现yum上面的版本和本地一样,应该是不能yum update samba了。。。只能源码安装</p>
<h2 id="备份Samba的信息"><a href="#备份Samba的信息" class="headerlink" title="备份Samba的信息"></a>备份Samba的信息</h2><h3 id="备份samba存的的数据"><a href="#备份samba存的的数据" class="headerlink" title="备份samba存的的数据"></a>备份samba存的的数据</h3><ul>
<li><p>看一下smb文件夹有多大，目前是560多G</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cd</span> /home</span><br><span class="line">du -h --max-depth=1</span><br></pre></td></tr></table></figure>
</li>
<li><p>看下当前系统还够不够放,发现/home目录下面18T的空间可用，所以就tar备份在这里</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">df -h</span><br></pre></td></tr></table></figure></li>
<li><p>备份/home/smb文件夹</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir smb_backup </span><br><span class="line"><span class="built_in">cd</span> smb_backup</span><br><span class="line">tar -jpcv -f 20200107_smb_backup.tar.bz2 /home/smb/</span><br></pre></td></tr></table></figure>
<p>上面的命令解释：-j为采用bzip2压缩; -p为保持文件权限; -c创建压缩; -v可视化压缩过程; -f后面跟着压缩文件的命令，也就是把/home/smb/文件夹压缩打包到20200107_smb_backup.tar.bz2这个文件</p>
<blockquote>
<p>注意：本次备份没有加-j参数，也就是不压缩只打包，因为-j太慢了。。。反正现在空间还很多</p>
</blockquote>
</li>
</ul>
<h3 id="备份Samba配置文件"><a href="#备份Samba配置文件" class="headerlink" title="备份Samba配置文件"></a>备份Samba配置文件</h3><ul>
<li><p>先查看当前状态</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service smb status </span><br><span class="line"><span class="comment"># 显示 Active: active (running)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>停止服务 </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">service smb stop</span><br><span class="line">service smb status </span><br><span class="line"><span class="comment"># 显示 Active: inactive (dead)</span></span><br></pre></td></tr></table></figure></li>
<li><p>备份</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">smbd -b | grep DIR</span><br><span class="line"><span class="comment"># 输出 PRIVATE_DIR: /var/lib/samba/private</span></span><br><span class="line">cp /var/lib/samba/private /home/smb_backup/20200107 <span class="comment">#samba数据库</span></span><br><span class="line">cp /etc/samba/smb.conf /home/smb_backup/20200107 <span class="comment">#samba主要配置文件</span></span><br></pre></td></tr></table></figure>
<h2 id="源码编译"><a href="#源码编译" class="headerlink" title="源码编译"></a>源码编译</h2></li>
</ul>
<blockquote>
<p>参考<a href="https://wiki.samba.org/index.php/Build_Samba_from_Source">官网文档</a>和官网<a href="https://wiki.samba.org/index.php/Package_Dependencies_Required_to_Build_Samba#Red_Hat_Enterprise_Linux_7_.2F_CentOS_7_.2F_Scientific_Linux_7">依赖说明</a></p>
</blockquote>
<ul>
<li><p>下载最新的官网stable源码（截止20210107）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://download.samba.org/pub/samba/stable/samba-4.13.3.tar.gz</span><br><span class="line">tar -zxf samba-4.13.3.tar.gz</span><br></pre></td></tr></table></figure></li>
<li><p>安装依赖</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">yum install attr bind-utils docbook-style-xsl gcc gdb krb5-workstation \</span><br><span class="line">       libsemanage-python libxslt perl perl-ExtUtils-MakeMaker \</span><br><span class="line">       perl-Parse-Yapp perl-Test-Base pkgconfig policycoreutils-python \</span><br><span class="line">       python2-crypto gnutls-devel libattr-devel keyutils-libs-devel \</span><br><span class="line">       libacl-devel libaio-devel libblkid-devel libxml2-devel openldap-devel \</span><br><span class="line">       pam-devel popt-devel python-devel readline-devel zlib-devel systemd-devel \</span><br><span class="line">       lmdb-devel jansson-devel gpgme-devel pygpgme libarchive-devel</span><br></pre></td></tr></table></figure>
<p>不出所料这样是失败的。。。错误信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Transaction check error:</span><br><span class="line">  file &#x2F;usr&#x2F;lib64&#x2F;libgnutlsxx.so.28.1.0 from install of gnutls-c++-3.3.29-9.el7_6.x86_64 conflicts with file from package compat-gnutls34-c++-3.4.17-6.el7.x86_64</span><br><span class="line">  file &#x2F;usr&#x2F;lib64&#x2F;libhogweed.so from install of nettle-devel-2.7.1-8.el7.x86_64 conflicts with file from package compat-nettle32-devel-3.2-3.el7.x86_64</span><br><span class="line">  file &#x2F;usr&#x2F;lib64&#x2F;libnettle.so from install of nettle-devel-2.7.1-8.el7.x86_64 conflicts with file from package compat-nettle32-devel-3.2-3.el7.x86_64</span><br><span class="line">  file &#x2F;usr&#x2F;lib64&#x2F;libgnutls-dane.so.0 from install of gnutls-dane-3.3.29-9.el7_6.x86_64 conflicts with file from package compat-gnutls34-dane-3.4.17-6.el7.x86_64</span><br><span class="line">  file &#x2F;usr&#x2F;lib64&#x2F;libgnutls-dane.so from install of gnutls-devel-3.3.29-9.el7_6.x86_64 conflicts with file from package compat-gnutls34-devel-3.4.17-6.el7.x86_64</span><br><span class="line">  file &#x2F;usr&#x2F;lib64&#x2F;libgnutls.so from install of gnutls-devel-3.3.29-9.el7_6.x86_64 conflicts with file from package compat-gnutls34-devel-3.4.17-6.el7.x86_64</span><br></pre></td></tr></table></figure>
<p>官网表示，红帽系列发行版7系列都没有满足的gnutls包</p>
<blockquote>
<p>Red Hat Enterprise Linux 7 and deritivites do not provide a GnuTLS version &gt;= 3.4.7, even when EPEL is used. Users building Samba 4.12 will need to obtain GnuTLS from outside RHEL7 / CentOS7 / EPEL to use Samba 4.12.</p>
</blockquote>
<p>所以第三方安装<code>gnutls</code>这个包</p>
</li>
<li><p>安装<code>gnutls</code></p>
<blockquote>
<p>目前官网最新的是3.6.15这个包，经过测试编译不通过，应该是和openssl版本有关系（当前为OpenSSL 1.1.1g），每次编译到src文件夹下面的时候就会报找不到openssl的某个函数的错误，因此用老版本的<strong>3.6.4</strong>，切记！</p>
</blockquote>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">mkdir 3rdpary</span><br><span class="line"><span class="built_in">cd</span> 3rdparty</span><br><span class="line">wget https://www.gnupg.org/ftp/gcrypt/gnutls/v3.6/gnutls-3.6.4.tar.xz</span><br><span class="line">tar -xvJf gnutls-3.6.4.tar.xz</span><br><span class="line">./configure  --without-p11-kit </span><br></pre></td></tr></table></figure>
<p>然后又出错了。。。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">configure: error: </span><br><span class="line">  ***</span><br><span class="line">  *** Libnettle 3.4.1 was not found.</span><br></pre></td></tr></table></figure></li>
<li><p>安装<code>Libnettle 3.4.1</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">wget https://ftp.gnu.org/gnu/nettle/nettle-3.4.1.tar.gz</span><br><span class="line">tar -zxf nettle-3.4.1.tar.gz</span><br><span class="line">./configure</span><br><span class="line">make</span><br></pre></td></tr></table></figure>
<p>make的时候又出错。。。我TM。。。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">rsa-sign-tr.c: 在函数‘sec_equal’中:</span><br><span class="line">rsa-sign-tr.c:243:3: 错误：只允许在 C99 模式下使用‘for’循环初始化声明</span><br><span class="line">   for (size_t i &#x3D; 0; i &lt; limbs; i++)</span><br><span class="line">   ^</span><br><span class="line">rsa-sign-tr.c:243:3: 附注：使用 -std&#x3D;c99 或 -std&#x3D;gnu99 来编译您的代码</span><br><span class="line">make[1]: *** [rsa-sign-tr.o] 错误 1</span><br><span class="line">make[1]: 离开目录“&#x2F;home&#x2F;smb_backup&#x2F;samba_src&#x2F;3rdparty&#x2F;nettle-3.4.1”</span><br><span class="line">make: *** [all] 错误 2</span><br></pre></td></tr></table></figure>
<p>大概意思是make有问题</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --disable-openssl --prefix=/usr/ </span><br><span class="line"><span class="comment">#上面两个追加参数很关键</span></span><br><span class="line"><span class="comment">#disable-openssl解决不编译到example文件夹的时候找不到openssl，直接跳过拉倒</span></span><br><span class="line"><span class="comment">#prefix解决后续找不到库的问题，默认安装是装在/usr/local/lib64下面，系统在/usr/lib64找</span></span><br><span class="line">vim config.make</span><br><span class="line"><span class="comment"># 在CFLAGS一行后面加上-std=c99</span></span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>

<p>libnettle<strong>安装好了</strong></p>
</li>
<li><p>继续安装<code>gnutls</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure  --without-p11-kit </span><br><span class="line"><span class="comment"># 还是失败</span></span><br><span class="line">  configure: error: </span><br><span class="line">    ***</span><br><span class="line">    *** Libunistring was not found. To use the included one, use --with-included-unistring</span><br><span class="line"><span class="comment">#安装Libunistring</span></span><br><span class="line">yum install libunistring-devel</span><br><span class="line">./configure  --without-p11-kit</span><br><span class="line">make</span><br><span class="line">make install</span><br></pre></td></tr></table></figure>
<p><strong>成功</strong>安装gnults</p>
</li>
<li><p>安装samba</p>
<p>即使安装了gnults，因为安装路径不在/usr/lib64，系统找不到，这里懒得重新编译安装了。。。直接软连接过去</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/lib/pkgconfig/gnutls.pc /usr/lib64/pkgconfig/gnutls.pc</span><br><span class="line"><span class="comment"># ln -sf会覆盖，先备份一下原来的</span></span><br><span class="line">cp /usr/lib64/libgnutls.so /usr/lib64/libgnutls.so.bak</span><br><span class="line">ln -sf /usr/<span class="built_in">local</span>/lib/libgnutls.so /usr/lib64/libgnutls.so</span><br><span class="line">cp /usr/lib64/libgnutls.so.30 /usr/lib64/libgnutls.so.30.bak</span><br><span class="line">ln -sf /usr/<span class="built_in">local</span>/lib/libgnutls.so.30 /usr/lib64/libgnutls.so.30</span><br></pre></td></tr></table></figure>
<p>再尝试编译</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">./configure --disable-python --without-ad-dc --without-json --without-libarchive  --without-acl-support </span><br><span class="line">make</span><br><span class="line"><span class="comment"># 输出 &#x27;build&#x27; finished successfully (12m15.538s)</span></span><br><span class="line">make install </span><br><span class="line"><span class="comment"># 输出 &#x27;install&#x27; finished successfully (3m9.860s)</span></span><br></pre></td></tr></table></figure>
<p>！！！<strong>成功了</strong></p>
<p>现在samba安装在/usr/local/samba文件夹下面</p>
</li>
</ul>
<h2 id="配置新的Samba，关掉旧的"><a href="#配置新的Samba，关掉旧的" class="headerlink" title="配置新的Samba，关掉旧的"></a>配置新的Samba，关掉旧的</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ln -s /usr/<span class="built_in">local</span>/samba/etc/smb.conf /usr/<span class="built_in">local</span>/samba/lib/smb.conf</span><br><span class="line">touch /etc/ld.so.conf.d/samba.conf</span><br><span class="line">vim /etc/ld.so.conf.d/samba.conf</span><br><span class="line"><span class="comment"># 添加/usr/local/samba/lib</span></span><br><span class="line">ldconfig</span><br><span class="line">touch /etc/profile.d/samba.sh</span><br><span class="line">vim /etc/profile.d/samba.sh</span><br><span class="line"><span class="comment"># 添加 export PATH=$PATH:/usr/local/samba/bin:/usr/local/samba/sbin</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>由于在<code>yum remove samba</code>命令会卸载太多的依赖，在这台资料服务器上不敢瞎搞，尝试着把/usr/local/samba/sbin的四个文件都ln -sf到了/usr/sbin<br>然后重启电脑，打开/usr/local/samba/var查看smbd的log文件，发现最新的日志是</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[2021&#x2F;01&#x2F;08 21:05:14.847119,  0] ..&#x2F;..&#x2F;source3&#x2F;smbd&#x2F;server.c:1784(main)</span><br><span class="line">  smbd version 4.13.3 started.</span><br><span class="line">  Copyright Andrew Tridgell and the Samba Team 1992-2020</span><br></pre></td></tr></table></figure>
<h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>貌似没啥问题了，机房网管表示扫不到漏洞了，数据也都在，各个用户的权限也不用重新配置。</p>
]]></content>
      <categories>
        <category>环境配置</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>面试小坑-64位数据的字节序转换</title>
    <url>/2021/06/09/%E9%9D%A2%E8%AF%95%E5%B0%8F%E5%9D%91-64%E4%BD%8D%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%97%E8%8A%82%E5%BA%8F%E8%BD%AC%E6%8D%A2/</url>
    <content><![CDATA[<p>上周面试TME，面试官叫我说一下怎么实现64位数据的字节序转换，当时没意识到他的考察点，就回答系统有<code>hton</code>等一系列函数实现大端序和小端序的转换，没注意到考察点在于<strong>64位数据</strong>。</p>
<a id="more"></a>

<p>网络编程中，只要<code>include &lt;arpa/inet.h&gt;</code>，便可以使用下面几个函数实现主机字节序（大部分CPU都是小端序）和网络字节序（大端序）的转换</p>
<ul>
<li>htons </li>
<li>htonl</li>
<li>ntohs</li>
<li>ntohl</li>
</ul>
<p>其中<code>h</code>表示<code>host</code>，<code>n</code>代表<code>net</code>，<code>s</code>表示<code>short</code>，<code>l</code>表示<code>long</code>。</p>
<p>也就是说最多支持32位的数据转换。</p>
<p>因为在网络编程中，网络数据的传输涉及到的字节序转换是<strong>自动</strong>的，上面这几个函数一般只会在向<code>sockaddr_in</code>结构体填充数据的时候用的上,比如端口号用<code>htons</code>函数，ip地址用<code>htonl</code>函数。</p>
<p>因此对于64位数据，可以使用位移的方法实现转换，下面给出<code>htonl_64</code>的测试。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式一：自己实现</span></span><br><span class="line"><span class="function"><span class="keyword">uint32_t</span> <span class="title">reversebytes_32</span><span class="params">(<span class="keyword">uint32_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (value &amp; <span class="number">0x000000FF</span>U) &lt;&lt; <span class="number">24</span> | (value &amp; <span class="number">0x0000FF00</span>U) &lt;&lt; <span class="number">8</span> |</span><br><span class="line">           (value &amp; <span class="number">0x00FF0000</span>U) &gt;&gt; <span class="number">8</span> | (value &amp; <span class="number">0xFF000000</span>U) &gt;&gt; <span class="number">24</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">reversebytes_64</span><span class="params">(<span class="keyword">uint64_t</span> value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 低32位转成小端</span></span><br><span class="line">    <span class="keyword">uint64_t</span> high_uint64 = <span class="keyword">uint64_t</span>(reversebytes_32(<span class="keyword">uint32_t</span>(value)));</span><br><span class="line">    <span class="comment">// 高32位转成小端</span></span><br><span class="line">    <span class="keyword">uint64_t</span> low_uint64 = (<span class="keyword">uint64_t</span>)reversebytes_32(<span class="keyword">uint32_t</span>(value &gt;&gt; <span class="number">32</span>));</span><br><span class="line">    <span class="keyword">return</span> (high_uint64 &lt;&lt; <span class="number">32</span>) + low_uint64;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方式二：利用了系统的函数</span></span><br><span class="line"><span class="function"><span class="keyword">uint64_t</span> <span class="title">htonl_64</span><span class="params">(<span class="keyword">uint64_t</span> in)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ((<span class="keyword">uint64_t</span>)htonl((in)&amp;<span class="number">0xFFFFFFFF</span>) &lt;&lt; <span class="number">32</span>) | htonl((in) &gt;&gt; <span class="number">32</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;32位:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">uint32_t</span> x = <span class="number">0x87654321</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;方式一: &quot;</span> &lt;&lt; hex &lt;&lt; htonl(x) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;方式二: &quot;</span> &lt;&lt; hex &lt;&lt; reversebytes_32(x) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;-------&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;64位:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">uint64_t</span> y = <span class="number">0x1234567887654321</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;方式一: &quot;</span> &lt;&lt; hex &lt;&lt; htonl_64(y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;方式二: &quot;</span> &lt;&lt; hex &lt;&lt; reversebytes_64(y) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">32位:</span><br><span class="line">方式一: 21436587</span><br><span class="line">方式二: 21436587</span><br><span class="line">-------</span><br><span class="line">64位:</span><br><span class="line">方式一: 2143658778563412</span><br><span class="line">方式二: 2143658778563412</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>字节序转换</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer刷题日记-数组</title>
    <url>/2020/08/16/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0-%E6%95%B0%E7%BB%84/</url>
    <content><![CDATA[<p>【剑指Offer刷题日记】的第一篇文章，从数组相关的面试题3开始！冲冲冲！</p>
<p>记录<a href="https://leetcode-cn.com/problemset/lcof/">剑指Offer</a>中<code>数组</code>相关的题目思路及解答。</p>
<p>文章会给出思路和代码，同时为了方便本地调试，还会提供相应的测试用例。</p>
<a id="more"></a>


<h1 id="剑指Offer3：数组中重复的数字"><a href="#剑指Offer3：数组中重复的数字" class="headerlink" title="剑指Offer3：数组中重复的数字"></a>剑指Offer3：数组中重复的数字</h1><p>题目：在一个长度为n的数组里的所有数字都在0到n-1的范围内。</p>
<p>数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。</p>
<p>请找出数组中任意一个重复的数字。</p>
<h2 id="思路1：双重遍历（超时）"><a href="#思路1：双重遍历（超时）" class="headerlink" title="思路1：双重遍历（超时）"></a>思路1：双重遍历（超时）</h2><h3 id="show-me-code"><a href="#show-me-code" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; nums.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[j]) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路2：排序之后单循环"><a href="#思路2：排序之后单循环" class="headerlink" title="思路2：排序之后单循环"></a>思路2：排序之后单循环</h2><h3 id="show-me-code-1"><a href="#show-me-code-1" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i]==nums[i+<span class="number">1</span>])&#123;</span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路3：哈希表"><a href="#思路3：哈希表" class="headerlink" title="思路3：哈希表"></a>思路3：哈希表</h2><h3 id="show-me-code-2"><a href="#show-me-code-2" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">    <span class="comment">//set的insert函数返回pair类型,second为bool变量表示是否插入成功</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (st.insert(nums[i]).second == <span class="literal">false</span>)&#123; <span class="comment">// set唯一性导致插入失败</span></span><br><span class="line">            <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="思路4：原地操作，空间复杂度O-1"><a href="#思路4：原地操作，空间复杂度O-1" class="headerlink" title="思路4：原地操作，空间复杂度O(1)"></a>思路4：原地操作，空间复杂度O(1)</h2><h3 id="show-me-code-3"><a href="#show-me-code-3" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findRepeatNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!nums.size())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt; <span class="number">0</span> || nums[i] &gt; nums.size() - <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (nums[i] != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//发现相同的值</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[nums[i]])</span><br><span class="line">                <span class="keyword">return</span> nums[i];</span><br><span class="line">            <span class="comment">//下标和值不是对应的话移动到交换元素</span></span><br><span class="line">            swap(nums[i], nums[nums[i]]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ans = findRepeatNumber(vec);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; ans &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 2或者3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer4：二维数组中的查找"><a href="#剑指Offer4：二维数组中的查找" class="headerlink" title="剑指Offer4：二维数组中的查找"></a>剑指Offer4：二维数组中的查找</h1><p>题目：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</p>
<p>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 </p>
<h2 id="思路：将矩阵旋转45°"><a href="#思路：将矩阵旋转45°" class="headerlink" title="思路：将矩阵旋转45°"></a>思路：将矩阵旋转45°</h2><p>由于矩阵从左到右递增，从上到下递增，旋转之后从顶点向下看就是一颗二叉搜索树</p>
<h3 id="show-me-code-4"><a href="#show-me-code-4" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findNumberIn2DArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;matrix, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = matrix.size() - <span class="number">1</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; j &lt; matrix[<span class="number">0</span>].size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix[i][j] &gt; target)</span><br><span class="line">            i--;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target)</span><br><span class="line">            j++;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; vec_mat = &#123;&#123;<span class="number">1</span>, <span class="number">4</span>, <span class="number">7</span>, <span class="number">11</span>, <span class="number">15</span>&#125;,</span><br><span class="line">                                   &#123;<span class="number">2</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">12</span>, <span class="number">19</span>&#125;,</span><br><span class="line">                                   &#123;<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">22</span>&#125;,</span><br><span class="line">                                   &#123;<span class="number">10</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">17</span>, <span class="number">24</span>&#125;,</span><br><span class="line">                                   &#123;<span class="number">18</span>, <span class="number">21</span>, <span class="number">23</span>, <span class="number">26</span>, <span class="number">30</span>&#125;&#125;;</span><br><span class="line">    findNumberIn2DArray(vec_mat, <span class="number">5</span>) ? <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; <span class="built_in">endl</span> : <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; <span class="built_in">endl</span>;  <span class="comment">// true</span></span><br><span class="line">    findNumberIn2DArray(vec_mat, <span class="number">20</span>) ? <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; <span class="built_in">endl</span> : <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer5：替换空格"><a href="#剑指Offer5：替换空格" class="headerlink" title="剑指Offer5：替换空格"></a>剑指Offer5：替换空格</h1><p>题目：请实现一个函数，把字符串中的每个空格替换成”%20”。<br>例如输入“We are happy.”， 则输出“We%20are%20happy.”。 </p>
<h2 id="思路：直接遍历，然后增删改查"><a href="#思路：直接遍历，然后增删改查" class="headerlink" title="思路：直接遍历，然后增删改查"></a>思路：直接遍历，然后增删改查</h2><h3 id="show-me-code-5"><a href="#show-me-code-5" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">replaceSpace</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ss = <span class="string">&quot;%20&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.erase(i, <span class="number">1</span>);</span><br><span class="line">            s.insert(i, ss);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **agrv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> s = <span class="string">&quot;we are happy&quot;</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; s &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; replaceSpace(s) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer11：旋转数组的最小数字"><a href="#剑指Offer11：旋转数组的最小数字" class="headerlink" title="剑指Offer11：旋转数组的最小数字"></a>剑指Offer11：旋转数组的最小数字</h1><p>题目：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。<br>输入一个递增排序的数组的一个旋转，输出旋转数组的最小元素。例如数组<br>{3, 4, 5, 1, 2}为{1, 2, 3, 4, 5}的一个旋转，该数组的最小值为1。</p>
<h2 id="思路1-遍历数组-找到最小的元素-这没有使用到旋转数组的性质"><a href="#思路1-遍历数组-找到最小的元素-这没有使用到旋转数组的性质" class="headerlink" title="思路1:遍历数组,找到最小的元素,这没有使用到旋转数组的性质"></a>思路1:遍历数组,找到最小的元素,这没有使用到旋转数组的性质</h2><h3 id="show-me-code-6"><a href="#show-me-code-6" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::const_iterator iter;</span><br><span class="line">    <span class="keyword">int</span> min = numbers[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (iter = numbers.begin(); iter != numbers.end(); iter++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (min &gt; *iter) &#123;</span><br><span class="line">            min = *iter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> min;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="思路2-原数组可以分成两个排序好的数组"><a href="#思路2-原数组可以分成两个排序好的数组" class="headerlink" title="思路2:原数组可以分成两个排序好的数组"></a>思路2:原数组可以分成两个排序好的数组</h2><ol>
<li>这两个数组的分界点右边的元素就是我们要找的元素，如 44|122</li>
<li>双指针法从两端搜索,每次找数组的中间元素,直到两个指针重合</li>
<li>注意边界情况：begin mid end指向的元素都相同 </li>
</ol>
<h3 id="show-me-code-7"><a href="#show-me-code-7" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;numbers)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 定义三个指针</span></span><br><span class="line">    <span class="keyword">int</span> begin = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> end = numbers.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//二分法套路</span></span><br><span class="line">    <span class="keyword">while</span> (begin &lt; end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>; <span class="comment">//防止数组溢出</span></span><br><span class="line">        <span class="keyword">if</span> (numbers[mid] &lt; numbers[end])</span><br><span class="line">        &#123;</span><br><span class="line">            end = mid;</span><br><span class="line">            <span class="comment">// mid比右边小,可能是最小值,因此缩小后的区间需要包含mid</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &gt; numbers[end])</span><br><span class="line">        &#123;</span><br><span class="line">            begin = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 这里很关键!!!</span></span><br><span class="line">            <span class="comment">// 因为mid比end大,所以mid肯定不是最小的元素,缩小区间的时候可以跳过mid元素到mid+1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            end--; <span class="comment">//此时mid和end相同,左移end指针</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numbers[begin];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-3"><a href="#测试用例-3" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v1 = &#123;<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v2 = &#123;<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>, <span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; minArray(v1) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//期望输出1</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; minArray(v2) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//期望输出0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer17-打印从1到最大的n位数"><a href="#剑指Offer17-打印从1到最大的n位数" class="headerlink" title="剑指Offer17. 打印从1到最大的n位数"></a>剑指Offer17. 打印从1到最大的n位数</h1><p>题目：输入数字 n，按顺序打印出从 1 到最大的 n 位十进制数。比如输入 3，则打印出 1、2、3 一直到最大的 3 位数 999。</p>
<h2 id="思路：字符串模拟数字加法"><a href="#思路：字符串模拟数字加法" class="headerlink" title="思路：字符串模拟数字加法"></a>思路：字符串模拟数字加法</h2><p>当n很大的时候，打印出来的数字会超过INT_MAX</p>
<p>先用string形式保存数,然后转为数组push_back进vector</p>
<ul>
<li>int转chat char c = int  i + ‘0’</li>
<li>char转int int  i = char c - ‘0’</li>
</ul>
<h3 id="show-me-code-8"><a href="#show-me-code-8" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">string2number</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> isBeginZero = <span class="literal">true</span>;</span><br><span class="line">    <span class="built_in">string</span> temp = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.length(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (isBeginZero &amp;&amp; s[i] != <span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">        &#123; <span class="comment">//找到了第一个不是起始0的数字</span></span><br><span class="line">            isBeginZero = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!isBeginZero)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = temp + s[i]; <span class="comment">//字符串重载了+号运算符,返回的是字符串连接后</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp != <span class="string">&quot;&quot;</span>)</span><br><span class="line">    &#123;                              <span class="comment">//输入是&quot;&quot;,stoi函数会报错</span></span><br><span class="line">        res.push_back(stoi(temp)); <span class="comment">//C++11的string转int函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursive</span><span class="params">(<span class="built_in">string</span> &amp;s, <span class="keyword">int</span> len, <span class="keyword">int</span> pos)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (len == pos)</span><br><span class="line">    &#123;</span><br><span class="line">        string2number(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        s[pos] = i + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        recursive(s, s.length(), pos + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">printNumbers</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">s</span><span class="params">(n, <span class="string">&#x27;0&#x27;</span>)</span></span>; <span class="comment">//构造一个长为n,每个元素都是&#x27;0&#x27;的字符串</span></span><br><span class="line">    recursive(s, s.length(), <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-4"><a href="#测试用例-4" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out = printNumbers(<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; out.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; out[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer21：调整数组顺序使奇数位于偶数前面"><a href="#剑指Offer21：调整数组顺序使奇数位于偶数前面" class="headerlink" title="剑指Offer21：调整数组顺序使奇数位于偶数前面"></a>剑指Offer21：调整数组顺序使奇数位于偶数前面</h1><p>题目：输入一个整数数组，实现一个函数来调整该数组中数字的顺序，使得所有奇数位于数组的前半部分，所有偶数位于数组的后半部分。</p>
<h2 id="思路1-最简单的方法-建立一个偶数数组-浪费空间"><a href="#思路1-最简单的方法-建立一个偶数数组-浪费空间" class="headerlink" title="思路1:最简单的方法,建立一个偶数数组,浪费空间"></a>思路1:最简单的方法,建立一个偶数数组,浪费空间</h2><h3 id="show-me-code-9"><a href="#show-me-code-9" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res_even;  <span class="comment">//偶数</span></span><br><span class="line">    <span class="keyword">int</span> i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">            res.push_back(nums[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res_even.push_back(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; res_even.size(); j++) &#123;</span><br><span class="line">        res.push_back(res_even[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="思路2-双指针-当左指针为偶-右指针为奇-交换两个数字"><a href="#思路2-双指针-当左指针为偶-右指针为奇-交换两个数字" class="headerlink" title="思路2:双指针,当左指针为偶,右指针为奇,交换两个数字"></a>思路2:双指针,当左指针为偶,右指针为奇,交换两个数字</h2><h3 id="show-me-code-10"><a href="#show-me-code-10" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">exchange</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] % <span class="number">2</span> == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            left++;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[right] % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            right--;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[left], nums[right]);</span><br><span class="line">        left++;</span><br><span class="line">        right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-5"><a href="#测试用例-5" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = exchange(nums);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i :res)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;<span class="comment">// 1 3 2 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer39：数组中出现次数超过一半的数字"><a href="#剑指Offer39：数组中出现次数超过一半的数字" class="headerlink" title="剑指Offer39：数组中出现次数超过一半的数字"></a>剑指Offer39：数组中出现次数超过一半的数字</h1><p>题目：数组中有一个数字出现的次数超过数组长度的一半，请找出这个数字。<br>例如输入一个长度为9的数组{1, 2, 3, 2, 2, 2, 5, 4, 2}。<br>由于数字2在数组中出现了5次，超过数组长度的一半，因此输出2。 </p>
<h2 id="思路1-对数组排序-最多的数组一定是中位数"><a href="#思路1-对数组排序-最多的数组一定是中位数" class="headerlink" title="思路1: 对数组排序,最多的数组一定是中位数"></a>思路1: 对数组排序,最多的数组一定是中位数</h2><p>时间复杂度: O(nlogn) </p>
<h3 id="show-me-code-11"><a href="#show-me-code-11" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">return</span> nums[nums.size() / <span class="number">2</span>];</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="思路2-哈希表统计次数"><a href="#思路2-哈希表统计次数" class="headerlink" title="思路2: 哈希表统计次数"></a>思路2: 哈希表统计次数</h2><h3 id="show-me-code-12"><a href="#show-me-code-12" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="keyword">if</span> (!nums.size()) &#123;</span><br><span class="line">        res = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; umap;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">        umap[nums[i]]++;</span><br><span class="line">        <span class="keyword">if</span> (umap[nums[i]] &gt; nums.size() / <span class="number">2</span>) &#123;</span><br><span class="line">            res = nums[i];</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="思路3-摩尔投票法"><a href="#思路3-摩尔投票法" class="headerlink" title="思路3: 摩尔投票法"></a>思路3: 摩尔投票法</h2><p>时间效率最好<br>诸侯纷争,轮流当王,最多的元素一定是最后的王<br>遍历一遍数组,同元素+1,不同元素-1 </p>
<h3 id="show-me-code-13"><a href="#show-me-code-13" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">majorityElement</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res = nums[i];</span><br><span class="line">            cnt = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (res == nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                cnt += <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                cnt -= <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-6"><a href="#测试用例-6" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">4</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; majorityElement(in) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer40：最小的k个数"><a href="#剑指Offer40：最小的k个数" class="headerlink" title="剑指Offer40：最小的k个数"></a>剑指Offer40：最小的k个数</h1><p>题目：输入n个整数，找出其中最小的k个数。例如输入4、5、1、6、2、7、3、8<br>这8个数字，则最小的4个数字是1、2、3、4。 </p>
<h2 id="思路1-排序"><a href="#思路1-排序" class="headerlink" title="思路1: 排序"></a>思路1: 排序</h2><h3 id="show-me-code-14"><a href="#show-me-code-14" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    sort(arr.begin(), arr.end());</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(arr.begin(), arr.begin() + k)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="思路2-最大堆解法"><a href="#思路2-最大堆解法" class="headerlink" title="思路2: 最大堆解法"></a>思路2: 最大堆解法</h2><p>这种方法适合处理大量数据 </p>
<h3 id="show-me-code-15"><a href="#show-me-code-15" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.size() || !k) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>&gt; que_less;  <span class="comment">// 优先队列默认把插入的元素从大到小(less)排序</span></span><br><span class="line">    <span class="comment">// 前k个元素填充队列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        que_less.push(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// k之后的元素,如果比队列中的最大元素小,就弹出队列中最大元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = k; j &lt; arr.size(); j++) &#123;</span><br><span class="line">        <span class="comment">// 优先队列默认是用less函数排序,即第一个元素最大</span></span><br><span class="line">        <span class="keyword">if</span> (arr[j] &lt; que_less.top()) &#123;</span><br><span class="line">            que_less.pop();</span><br><span class="line">            que_less.push(arr[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!que_less.empty()) &#123;</span><br><span class="line">        res.push_back(que_less.top());</span><br><span class="line">        que_less.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路3-快速选择"><a href="#思路3-快速选择" class="headerlink" title="思路3: 快速选择"></a>思路3: 快速选择</h2><ol>
<li>类似快排,依靠partition函数,将数组分为”比pivot小”和”比pivot大”两部分,并返回pivot在数组的下标pos)</li>
<li>与快排不同的是,不需要递归处理两侧的部分,而是选择一部分递归</li>
<li>当pos = index 返回左半边的数组</li>
<li>当pos &gt; index 递归左半部分,直到pos = k</li>
<li>当pos &lt; index 还需要在右边再找k-pos个元素 </li>
</ol>
<h3 id="show-me-code-16"><a href="#show-me-code-16" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res; <span class="comment">// 递归调用的话,全局变量可以减少参数</span></span><br><span class="line"><span class="comment">// 参考的是大话数据结构p418里面的写法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pivot = arr[left]; <span class="comment">// 用左指针的元素做pivot(也可以用rand生成随机数)</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 下面等号不能少,否则超时</span></span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[right] &gt; pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            right -= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr[right], arr[left]);</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right &amp;&amp; arr[left] &lt; pivot)</span><br><span class="line">        &#123;</span><br><span class="line">            left += <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(arr[left], arr[right]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面传进来的各个参数,都是数组中的下标,即从0开始</span></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">quickSelect</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = partition(arr, left, right);</span><br><span class="line">    <span class="keyword">if</span> (pos == index)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 这里要拷贝到pos处的元素,因为pos(即index)指的是第k小元素的下标</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= pos; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos &gt; index ? quickSelect(arr, left, pos - <span class="number">1</span>, index)</span><br><span class="line">                       : quickSelect(arr, pos + <span class="number">1</span>, right, index);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">getLeastNumbers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;arr, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!arr.size() || !k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// !!!传k-1进去,因为第k个变量的下标是k-1</span></span><br><span class="line">    <span class="keyword">return</span> quickSelect(arr, <span class="number">0</span>, arr.size() - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-7"><a href="#测试用例-7" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> agrc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in1 = &#123;<span class="number">3</span>, <span class="number">2</span>, <span class="number">1</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; out1 = getLeastNumbers(in1, <span class="number">2</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : out1)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// 1 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer41：数据流中的中位数"><a href="#剑指Offer41：数据流中的中位数" class="headerlink" title="剑指Offer41：数据流中的中位数"></a>剑指Offer41：数据流中的中位数</h1><p>题目：如何得到一个数据流中的中位数？如果从数据流中读出奇数个数值，那么<br>中位数就是所有数值排序之后位于中间的数值。如果从数据流中读出偶数个数值，<br>那么中位数就是所有数值排序之后中间两个数的平均值。 </p>
<h2 id="思路-建立两个优先队列-一个为最大堆-一个为最小堆"><a href="#思路-建立两个优先队列-一个为最大堆-一个为最小堆" class="headerlink" title="思路:建立两个优先队列,一个为最大堆,一个为最小堆"></a>思路:建立两个优先队列,一个为最大堆,一个为最小堆</h2><p>向这两个优先队列插入元素,保证:<br>1.最大堆的所有元素 比 最小堆中的所有元素 小<br>2.两个优先队列的数目差距最大为1 </p>
<h3 id="show-me-code-17"><a href="#show-me-code-17" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, less&lt;<span class="keyword">int</span>&gt;&gt; maxHeap;</span><br><span class="line"><span class="built_in">priority_queue</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; minHeap;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addNum</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 两个堆元素相同,先插入最大堆,然后把最大堆的栈顶元素移到最小堆中</span></span><br><span class="line">    <span class="comment">// 这样就保证了最大堆的所有元素都比最小堆的元素小(因为最大堆中最大的被移到最小堆了)</span></span><br><span class="line">    <span class="keyword">if</span> (maxHeap.size() == minHeap.size())</span><br><span class="line">    &#123;</span><br><span class="line">        maxHeap.push(num);</span><br><span class="line">        minHeap.push(maxHeap.top());</span><br><span class="line">        maxHeap.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 两个堆个数不同(即相差1),方法同上</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        minHeap.push(num);</span><br><span class="line">        maxHeap.push(minHeap.top());</span><br><span class="line">        minHeap.pop();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">findMedian</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 分奇偶讨论</span></span><br><span class="line">    <span class="keyword">if</span> (maxHeap.size() == minHeap.size())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> (maxHeap.top() + minHeap.top()) / <span class="number">2.0</span>; <span class="comment">// 必须要用/2.0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> minHeap.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-8"><a href="#测试用例-8" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    addNum(<span class="number">1</span>);</span><br><span class="line">    addNum(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; findMedian() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    addNum(<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; findMedian() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer44：数字序列中某一位的数字"><a href="#剑指Offer44：数字序列中某一位的数字" class="headerlink" title="剑指Offer44：数字序列中某一位的数字"></a>剑指Offer44：数字序列中某一位的数字</h1><p>题目：数字以0123456789101112131415…的格式序列化到一个字符序列中。<br>在这个序列中，第5位（从0开始计数）是5，第13位是1，第19位是4，等等。<br>请写一个函数求任意位对应的数字。 </p>
<h3 id="show-me-code-18"><a href="#show-me-code-18" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> digit = <span class="number">1</span>;       <span class="comment">//几位数</span></span><br><span class="line">    <span class="keyword">long</span> digitBegin = <span class="number">1</span>; <span class="comment">//该位数的开始</span></span><br><span class="line">    <span class="keyword">long</span> digitLen = <span class="number">9</span>;   <span class="comment">//该位所有数字共有多长</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= digitLen) <span class="comment">//说明在这一位中</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 不在这一位，进入递推公式</span></span><br><span class="line">        n -= digitLen;</span><br><span class="line">        ++digit;</span><br><span class="line">        digitBegin *= <span class="number">10</span>;</span><br><span class="line">        digitLen = digit * digitBegin * <span class="number">9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到具体是哪个数字,很重要的注意索引是从0开始，所以要(n-1)</span></span><br><span class="line">    <span class="keyword">int</span> digitNums = (n - <span class="number">1</span>) / digit;        <span class="comment">// 有几个 某位数</span></span><br><span class="line">    <span class="keyword">int</span> digitRes = (n - <span class="number">1</span>) % digit;         <span class="comment">// 余数</span></span><br><span class="line">    <span class="keyword">long</span> finalNum = digitBegin + digitNums; <span class="comment">// 找到这个数字了</span></span><br><span class="line">    <span class="comment">// 之后就是根据余数确定哪一位的问题,这里用转为string的方式</span></span><br><span class="line">    <span class="built_in">string</span> s_finalNum = to_string(finalNum);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">int</span>(s_finalNum[digitRes] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-9"><a href="#测试用例-9" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **agrv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n=3: &quot;</span> &lt;&lt; findNthDigit(<span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;       <span class="comment">// out:3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n=11: &quot;</span> &lt;&lt; findNthDigit(<span class="number">11</span>) &lt;&lt; <span class="built_in">endl</span>;     <span class="comment">// out:0</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;n=1001: &quot;</span> &lt;&lt; findNthDigit(<span class="number">1001</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// out:7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer45：把数组排成最小的数"><a href="#剑指Offer45：把数组排成最小的数" class="headerlink" title="剑指Offer45：把数组排成最小的数"></a>剑指Offer45：把数组排成最小的数</h1><p>题目：输入一个正整数数组，把数组里所有数字拼接起来排成一个数，打印能拼<br>接出的所有数字中最小的一个。例如输入数组{3, 32, 321}，则打印出这3个数<br>字能排成的最小数字321323。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><ol>
<li>按照最高位从小到大排序</li>
<li>最高位相同的话，比较ab和ba哪个大</li>
</ol>
<h3 id="show-me-code-19"><a href="#show-me-code-19" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">minNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.empty())</span><br><span class="line">        <span class="keyword">return</span> to_string(<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; strs;</span><br><span class="line">    <span class="built_in">string</span> res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        strs.push_back(to_string(i));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// sort结合lambda表达式自定义排序</span></span><br><span class="line">    sort(strs.begin(), strs.end(), [](<span class="keyword">const</span> <span class="built_in">string</span> &amp;s1, <span class="keyword">const</span> <span class="built_in">string</span> &amp;s2) &#123;</span><br><span class="line">        <span class="comment">// 1.根据最高位判断位置</span></span><br><span class="line">        <span class="keyword">if</span> (s1[<span class="number">0</span>] != s2[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">return</span> s1[<span class="number">0</span>] &lt; s2[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 2.最高位相同的话判断ab还是ba</span></span><br><span class="line">        <span class="keyword">return</span> s1 + s2 &lt; s2 + s1;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">string</span> i : strs)</span><br><span class="line">    &#123;</span><br><span class="line">        res += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-10"><a href="#测试用例-10" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1 = &#123;<span class="number">10</span>, <span class="number">2</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; minNumber(vec1) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//102</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2 = &#123;<span class="number">3</span>, <span class="number">30</span>, <span class="number">34</span>, <span class="number">5</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; minNumber(vec2) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//3033459</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer53（一）：数字在排序数组中出现的次数"><a href="#剑指Offer53（一）：数字在排序数组中出现的次数" class="headerlink" title="剑指Offer53（一）：数字在排序数组中出现的次数"></a>剑指Offer53（一）：数字在排序数组中出现的次数</h1><p>题目：统计一个数字在排序数组中出现的次数。</p>
<h2 id="思路1-遍历数组"><a href="#思路1-遍历数组" class="headerlink" title="思路1:遍历数组"></a>思路1:遍历数组</h2><h3 id="show-me-code-20"><a href="#show-me-code-20" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == target)</span><br><span class="line">            ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路2-哈希表"><a href="#思路2-哈希表" class="headerlink" title="思路2:哈希表"></a>思路2:哈希表</h2><h3 id="show-me-code-21"><a href="#show-me-code-21" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="built_in">map</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i : nums) &#123;</span><br><span class="line">        ++<span class="built_in">map</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="built_in">map</span>.find(target)-&gt;second;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路3"><a href="#思路3" class="headerlink" title="思路3"></a>思路3</h2><p>由于是一个排序的数列，可以采用二分法快速搜索<br>二分的目的是找到target区间的左右端点，最后返回r-l+1就是个数</p>
<h3 id="show-me-code-22"><a href="#show-me-code-22" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L, R;</span><br><span class="line">    <span class="comment">// 找right</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// &lt;= 是为了确定右边界</span></span><br><span class="line">        <span class="comment">// 当mid等于target时，因为不确定后面还有没有target，所以同样需要左边收缩范围</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt;= target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    R = right;</span><br><span class="line">    <span class="comment">// 找left</span></span><br><span class="line">    left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// &lt; 是为了确定左边界</span></span><br><span class="line">        <span class="comment">// 因为就算当mid等于target的时候，因为不确定左边还有没有target，所以同样需要收缩右边界</span></span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target)</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    L = left;</span><br><span class="line">    <span class="keyword">return</span> R - L + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-11"><a href="#测试用例-11" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1 = &#123;<span class="number">5</span>, <span class="number">7</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">8</span>, <span class="number">10</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; search(vec1, <span class="number">8</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 输出2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer53（二）：0到n-1中缺失的数字"><a href="#剑指Offer53（二）：0到n-1中缺失的数字" class="headerlink" title="剑指Offer53（二）：0到n-1中缺失的数字"></a>剑指Offer53（二）：0到n-1中缺失的数字</h1><p>题目：一个长度为n-1的递增排序数组中的所有数字都是唯一的，并且每个数字都在范围0到n-1之内。<br>在范围0到n-1的n个数字中有且只有一个数字不在该数组中，请找出这个数字。</p>
<h2 id="思路：二分法"><a href="#思路：二分法" class="headerlink" title="思路：二分法"></a>思路：二分法</h2><p>长度为n-1且递增的数组，应该满足nums[i] = i<br>需要用二分法找到不满足这个条件的数字</p>
<h3 id="show-me-code-23"><a href="#show-me-code-23" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">missingNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = nums.size() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m = (L + R) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[m] == m)</span><br><span class="line">            L = m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            R = m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 离开while循环之后，L指向缺少数字的位置</span></span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-12"><a href="#测试用例-12" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; missingNumber(vec) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer61：扑克牌的顺子"><a href="#剑指Offer61：扑克牌的顺子" class="headerlink" title="剑指Offer61：扑克牌的顺子"></a>剑指Offer61：扑克牌的顺子</h1><p>题目：从扑克牌中随机抽5张牌，判断是不是一个顺子，即这5张牌是不是连续的。<br>2～10为数字本身，A为1，J为11，Q为12，K为13，而大、小王为 0 ，可以看成任意数字。A 不能视为 14。</p>
<h2 id="思路：排序-遍历检查"><a href="#思路：排序-遍历检查" class="headerlink" title="思路：排序+遍历检查"></a>思路：排序+遍历检查</h2><p>用0的个数来补充相邻的距离</p>
<h3 id="show-me-code-24"><a href="#show-me-code-24" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isStraight</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> jocker_num = <span class="number">0</span>;</span><br><span class="line">    sort(nums.begin(), nums.end());</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ++jocker_num;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止越界</span></span><br><span class="line">        <span class="keyword">if</span> (i + <span class="number">1</span> &lt; <span class="number">5</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 出现相同的非零元素</span></span><br><span class="line">            <span class="keyword">if</span> (nums[i] == nums[i + <span class="number">1</span>])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> dis = nums[i + <span class="number">1</span>] - nums[i];</span><br><span class="line">            <span class="keyword">while</span> (dis &gt; <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (jocker_num == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                --jocker_num;</span><br><span class="line">                --dis;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-13"><a href="#测试用例-13" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; test1 = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; isStraight(test1) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer62：圆圈中最后剩下的数字"><a href="#剑指Offer62：圆圈中最后剩下的数字" class="headerlink" title="剑指Offer62：圆圈中最后剩下的数字"></a>剑指Offer62：圆圈中最后剩下的数字</h1><p>题目：0, 1, …, n-1这n个数字排成一个圆圈，从数字0开始每次从这个圆圈里删除第m个数字。<br>求出这个圆圈里剩下的最后一个数字。</p>
<h2 id="思路1：模拟环形链表，该方法超时"><a href="#思路1：模拟环形链表，该方法超时" class="headerlink" title="思路1：模拟环形链表，该方法超时"></a>思路1：模拟环形链表，该方法超时</h2><h3 id="show-me-code-25"><a href="#show-me-code-25" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 链表初始化</span></span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; nums;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num = <span class="number">0</span>; num &lt; n; ++num)</span><br><span class="line">        nums.push_back(num);</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator cur = nums.begin();</span><br><span class="line">    <span class="keyword">while</span> (nums.size() &gt; <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 找到要删除的节点</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            cur++;</span><br><span class="line">            <span class="comment">// 模拟环形</span></span><br><span class="line">            <span class="keyword">if</span> (cur == nums.end())</span><br><span class="line">                cur = nums.begin();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt;::iterator next = ++cur;</span><br><span class="line">        <span class="keyword">if</span> (next == nums.end())</span><br><span class="line">            next = nums.begin();</span><br><span class="line">        --cur;</span><br><span class="line">        nums.erase(cur);</span><br><span class="line">        <span class="comment">//第二次循环的开始</span></span><br><span class="line">        cur = next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> *(cur);</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="思路2：数学问题约瑟夫环"><a href="#思路2：数学问题约瑟夫环" class="headerlink" title="思路2：数学问题约瑟夫环"></a>思路2：数学问题约瑟夫环</h2><p><a href="https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/">https://leetcode-cn.com/problems/yuan-quan-zhong-zui-hou-sheng-xia-de-shu-zi-lcof/solution/huan-ge-jiao-du-ju-li-jie-jue-yue-se-fu-huan-by-as/</a></p>
<h3 id="show-me-code-26"><a href="#show-me-code-26" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lastRemaining</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>; <span class="comment">// 最终活下来那个人的初始位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pos = (pos + m) % i; <span class="comment">// 每次循环右移</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pos;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-14"><a href="#测试用例-14" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; lastRemaining(<span class="number">5</span>, <span class="number">3</span>) &lt;&lt; <span class="built_in">endl</span>;   <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; lastRemaining(<span class="number">10</span>, <span class="number">17</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剑指Offer66：构建乘积数组"><a href="#剑指Offer66：构建乘积数组" class="headerlink" title="剑指Offer66：构建乘积数组"></a>剑指Offer66：构建乘积数组</h1><p>给定一个数组 A[0,1,…,n-1]，请构建一个数组 B[0,1,…,n-1]，其中 B[i] 的值是数组 A 中除了下标 i 以外的元素的积,<br>即 B[i]=A[0]×A[1]×…×A[i-1]×A[i+1]×…×A[n-1]。</p>
<p>不能使用除法。</p>
<h2 id="思路1：O-N-2-遍历"><a href="#思路1：O-N-2-遍历" class="headerlink" title="思路1：O(N^2)遍历"></a>思路1：O(N^2)遍历</h2><p>超时不能通过</p>
<h3 id="show-me-code-27"><a href="#show-me-code-27" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">constructArr</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(a.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; a.size(); ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != j)</span><br><span class="line">                res[i] *= a[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路2：两次遍历"><a href="#思路2：两次遍历" class="headerlink" title="思路2：两次遍历"></a>思路2：两次遍历</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">b0 &#x3D; 1  * a1 * a2 * a3</span><br><span class="line">b1 &#x3D; a0 * 1  * a2 * a3</span><br><span class="line">b2 &#x3D; a0 * a1 * 1  * a3</span><br><span class="line">b3 &#x3D; a0 * a1 * a2 * 1 </span><br></pre></td></tr></table></figure>
<p>沿着对角线1把计算B的过程分为两部分：左下 和 右上</p>
<h3 id="show-me-code-28"><a href="#show-me-code-28" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">constructArr</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> size = a.size();</span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(size, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 一次遍历得到左下</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; size; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        b[i] = b[i - <span class="number">1</span>] * a[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 二次遍历得到右上</span></span><br><span class="line">    <span class="keyword">int</span> RU = <span class="number">1</span>; <span class="comment">// 右上角乘积</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">    &#123;</span><br><span class="line">        RU = RU * a[i + <span class="number">1</span>];</span><br><span class="line">        b[i] = b[i] * RU;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-15"><a href="#测试用例-15" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : constructArr(in))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; i &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="comment">// [120,60,40,30,24]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>数组</tag>
      </tags>
  </entry>
  <entry>
    <title>剑指Offer刷题日记-二叉树</title>
    <url>/2020/08/19/%E5%89%91%E6%8C%87Offer%E5%88%B7%E9%A2%98%E6%97%A5%E8%AE%B0-%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
    <content><![CDATA[<p>记录<a href="https://leetcode-cn.com/problemset/lcof/">剑指Offer</a>中<code>二叉树</code>相关的题目思路及解答。</p>
<p>文章会给出思路和代码，同时为了方便本地调试，还会提供相应的测试用例。</p>
<a id="more"></a>

<p>如果要在本地调试，需要先包含下面的头文件。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MY_TREE_NODE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_TREE_NODE</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    TreeNode(<span class="keyword">int</span> x) : val(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printTree</span><span class="params">(TreeNode *pNode)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;node: &quot;</span> &lt;&lt; pNode-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;left: &quot;</span> &lt;&lt; pNode-&gt;left-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;left: NULL &quot;</span>;</span><br><span class="line">        <span class="keyword">if</span> (pNode-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;right: &quot;</span> &lt;&lt; pNode-&gt;right-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;right: NULL&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pNode-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printTree(pNode-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pNode-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        printTree(pNode-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<!-- more -->

<h1 id="剑指Offer7：重建二叉树"><a href="#剑指Offer7：重建二叉树" class="headerlink" title="剑指Offer7：重建二叉树"></a>剑指Offer7：重建二叉树</h1><p>题目：输入某二叉树的前序遍历和中序遍历的结果，请重建该二叉树。</p>
<p>假设输入的前序遍历和中序遍历的结果中都不含重复的数字。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，给出</span><br><span class="line">前序遍历 preorder &#x3D; [3,9,20,15,7]</span><br><span class="line">中序遍历 inorder &#x3D; [9,3,15,20,7]</span><br><span class="line">返回如下的二叉树：</span><br><span class="line">    3</span><br><span class="line">   &#x2F; \</span><br><span class="line">  9  20</span><br><span class="line">    &#x2F;  \</span><br><span class="line">   15   7 </span><br></pre></td></tr></table></figure>

<h3 id="show-me-code"><a href="#show-me-code" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">buildTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;preorder, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;inorder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (preorder.size() == <span class="number">0</span> || inorder.size() == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; preorder_left, preorder_right;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; inorder_left, inorder_right;</span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(preorder[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据前序遍历的第一个节点(根节点)将中序遍历分为两棵子树</span></span><br><span class="line">    <span class="keyword">int</span> pos; <span class="comment">//根节点在中序遍历中的位置</span></span><br><span class="line">    <span class="keyword">for</span> (pos = <span class="number">0</span>; pos &lt; inorder.size(); pos++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[pos] == preorder[<span class="number">0</span>])</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        inorder_left.push_back(inorder[pos]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (pos = pos + <span class="number">1</span>; pos &lt; inorder.size(); pos++)</span><br><span class="line">        inorder_right.push_back(inorder[pos]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//把前序遍历分成左右两棵子树</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; preorder.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= inorder_left.size())</span><br><span class="line">            preorder_left.push_back(preorder[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            preorder_right.push_back(preorder[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;left = buildTree(preorder_left, inorder_left);</span><br><span class="line">    root-&gt;right = buildTree(preorder_right, inorder_right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例"><a href="#测试用例" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pre_vec = &#123;<span class="number">3</span>, <span class="number">9</span>, <span class="number">20</span>, <span class="number">15</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in_vec = &#123;<span class="number">9</span>, <span class="number">3</span>, <span class="number">15</span>, <span class="number">20</span>, <span class="number">7</span>&#125;;</span><br><span class="line">    TreeNode *tree = buildTree(pre_vec, in_vec);</span><br><span class="line">    printTree(tree);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer8：二叉树的下一个结点"><a href="#剑指Offer8：二叉树的下一个结点" class="headerlink" title="剑指Offer8：二叉树的下一个结点"></a>剑指Offer8：二叉树的下一个结点</h1><p>题目：给定一棵二叉树和其中的一个结点，如何找出中序遍历顺序的下一个节点？</p>
<p>树中的结点除了有两个分别指向左右子结点的指针以外，还有一个指向父结点的指针 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">BinaryTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    BinaryTreeNode *left;</span><br><span class="line">    BinaryTreeNode *right;</span><br><span class="line">    BinaryTreeNode *parent;</span><br><span class="line">    BinaryTreeNode(<span class="keyword">int</span> x) : value(x), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>), parent(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectTree</span><span class="params">(BinaryTreeNode *parent, BinaryTreeNode *left, BinaryTreeNode *right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    parent-&gt;left = left;</span><br><span class="line">    parent-&gt;right = right;</span><br><span class="line">    left-&gt;parent = parent;</span><br><span class="line">    right-&gt;parent = parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路：中序遍历"><a href="#思路：中序遍历" class="headerlink" title="思路：中序遍历"></a>思路：中序遍历</h2><p>左递归-&gt;打印-&gt;右递归存在3种情况:</p>
<ol>
<li>打印该节点之后,存在右子节点,进入右递归,接下来打印的是右递归子树的最左节点</li>
<li>打印该节点之后,不存在右子节点,且该节点是父节点的左节点,接下来打印这个节点的父节点(用入栈出栈理解递归)</li>
<li>打印该节点之后,不存在右子节点,且该节点是父节点的右节点,需要回溯父节点,直到找到一个左子节点,返回这个左子节点的父节点 </li>
</ol>
<h3 id="show-me-code-1"><a href="#show-me-code-1" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">BinaryTreeNode *<span class="title">getNext</span><span class="params">(BinaryTreeNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    BinaryTreeNode *res = <span class="literal">NULL</span>; <span class="comment">// 返回值</span></span><br><span class="line">    <span class="comment">// 情况1</span></span><br><span class="line">    <span class="keyword">if</span> (node-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode *rightTree = node-&gt;right; <span class="comment">//该节点的右子树</span></span><br><span class="line">        <span class="comment">// 找最左</span></span><br><span class="line">        <span class="keyword">while</span> (rightTree-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rightTree = rightTree-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        res = rightTree;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        BinaryTreeNode *current = node;        <span class="comment">//当前节点</span></span><br><span class="line">        BinaryTreeNode *parent = node-&gt;parent; <span class="comment">//该节点的父节点</span></span><br><span class="line">        <span class="keyword">while</span> (parent != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 情况2</span></span><br><span class="line">            <span class="keyword">if</span> (parent-&gt;left == current)</span><br><span class="line">            &#123;</span><br><span class="line">                res = parent;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 情况3</span></span><br><span class="line">            current = parent;</span><br><span class="line">            parent = parent-&gt;parent;</span><br><span class="line">            <span class="keyword">if</span> (parent != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (current == parent-&gt;left &amp;&amp; parent != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                res = current-&gt;parent;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-1"><a href="#测试用例-1" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//     3</span></span><br><span class="line">    <span class="comment">//    / \</span></span><br><span class="line">    <span class="comment">//   9  20</span></span><br><span class="line">    <span class="comment">//     /  \</span></span><br><span class="line">    <span class="comment">//    15   7</span></span><br><span class="line">    <span class="comment">// 中序遍历[9,3,15,20,7 ]</span></span><br><span class="line">    BinaryTreeNode *node3 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">3</span>);</span><br><span class="line">    BinaryTreeNode *node9 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">9</span>);</span><br><span class="line">    BinaryTreeNode *node20 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">20</span>);</span><br><span class="line">    BinaryTreeNode *node15 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">15</span>);</span><br><span class="line">    BinaryTreeNode *node7 = <span class="keyword">new</span> BinaryTreeNode(<span class="number">7</span>);</span><br><span class="line">    connectTree(node3, node9, node20);</span><br><span class="line">    connectTree(node20, node15, node7);</span><br><span class="line">    BinaryTreeNode *next = <span class="literal">NULL</span>;</span><br><span class="line">    next = getNext(node9);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; next-&gt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    next = getNext(node3);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; next-&gt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    next = getNext(node15);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; next-&gt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    next = getNext(node20);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; next-&gt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    next = getNext(node7);</span><br><span class="line">    <span class="keyword">if</span> (next == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;NULL&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; next-&gt;value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer26：树的子结构"><a href="#剑指Offer26：树的子结构" class="headerlink" title="剑指Offer26：树的子结构"></a>剑指Offer26：树的子结构</h1><p>题目：输入两棵二叉树A和B，判断B是不是A的子结构。(约定空树不是任意一个树的子结构)<br>B是A的子结构， 即 A中有出现和B相同的结构和节点值。</p>
<h2 id="思路"><a href="#思路" class="headerlink" title="思路:"></a>思路:</h2><ol>
<li>对Ａ遍历，找到A中和Ｂ的根节点value相同的节点RA</li>
<li>判断以RA为根节点的子树是否和B相同</li>
</ol>
<h3 id="show-me-code-2"><a href="#show-me-code-2" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBinA</span><span class="params">(TreeNode *A, TreeNode *B)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在isSubStructure函数中对A树*先序遍历*，同时对每个A树的结点和Ｂ树的*根节点*进行isBinA查找</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSubStructure</span><span class="params">(TreeNode *A, TreeNode *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">NULL</span> || B == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (A-&gt;val == B-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        res = isBinA(A, B); <span class="comment">//如果A,B的根节点就相同,进入isBinA函数检查是否有相同的结构</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果根节点不满足相同结构,就递归左右子树</span></span><br><span class="line">    <span class="keyword">if</span> (!res)</span><br><span class="line">    &#123;</span><br><span class="line">        res = isSubStructure(A-&gt;left, B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!res)</span><br><span class="line">    &#123;</span><br><span class="line">        res = isSubStructure(A-&gt;right, B);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 找B是否在A中存在，且使用递归的形式，递归的重点是当B为空</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBinA</span><span class="params">(TreeNode *A, TreeNode *B)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (B == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">//B为空,说明此时B递归到了叶子节点</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (A == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (A-&gt;val != B-&gt;val)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当上面的三个if都不满足的时候，说明此时A.val == B.val，可以递归</span></span><br><span class="line">    <span class="keyword">return</span> isBinA(A-&gt;left, B-&gt;left) &amp;&amp; isBinA(A-&gt;right, B-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-2"><a href="#测试用例-2" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **agrv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// A树</span></span><br><span class="line">    TreeNode *TNode3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    TreeNode *TNode4 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">    TreeNode *TNode5 = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">    TreeNode *TNode1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">    TreeNode *TNode2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    TNode3-&gt;left = TNode4;</span><br><span class="line">    TNode3-&gt;right = TNode5;</span><br><span class="line">    TNode4-&gt;left = TNode1;</span><br><span class="line">    TNode4-&gt;right = TNode2;</span><br><span class="line">    <span class="comment">// B树</span></span><br><span class="line">    TreeNode *TNodeB4 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">    TreeNode *TNodeB1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">    TNodeB4-&gt;left = TNodeB1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isSubStructure(TNode3, TNodeB4))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;True&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer27：二叉树的镜像"><a href="#剑指Offer27：二叉树的镜像" class="headerlink" title="剑指Offer27：二叉树的镜像"></a>剑指Offer27：二叉树的镜像</h1><p>题目：请完成一个函数，输入一个二叉树，该函数输出它的镜像。</p>
<h2 id="思路-前序遍历-当遍历到的节点存在子节点时-交换子节点"><a href="#思路-前序遍历-当遍历到的节点存在子节点时-交换子节点" class="headerlink" title="思路:前序遍历,当遍历到的节点存在子节点时,交换子节点"></a>思路:前序遍历,当遍历到的节点<em>存在子节点</em>时,交换子节点</h2><h3 id="show-me-code-3"><a href="#show-me-code-3" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">mirrorTree</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        swap(root-&gt;left, root-&gt;right); <span class="comment">//这里用的是STL里面的swap函数,自己写的当左右节点有一个是空的时候不会处理</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mirrorTree(root-&gt;left);</span><br><span class="line">    mirrorTree(root-&gt;right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-3"><a href="#测试用例-3" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *node4 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">    TreeNode *node2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    TreeNode *node7 = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">    TreeNode *node1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">    TreeNode *node3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    TreeNode *node6 = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">    TreeNode *node9 = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line">    node4-&gt;left = node2;</span><br><span class="line">    node4-&gt;right = node7;</span><br><span class="line">    node2-&gt;left = node1;</span><br><span class="line">    node2-&gt;right = node3;</span><br><span class="line">    node7-&gt;left = node6;</span><br><span class="line">    node7-&gt;right = node9;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;镜像前：&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printTree(node4);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;镜像后:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    TreeNode *mirror = mirrorTree(node4);</span><br><span class="line">    printTree(mirror);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer28：对称的二叉树"><a href="#剑指Offer28：对称的二叉树" class="headerlink" title="剑指Offer28：对称的二叉树"></a>剑指Offer28：对称的二叉树</h1><p>题目：请实现一个函数，用来判断一棵二叉树是不是对称的。如果一棵二叉树和它的镜像一样，那么它是对称的。</p>
<h2 id="思路-自顶向下递归-比较左右一对节点是否相同"><a href="#思路-自顶向下递归-比较左右一对节点是否相同" class="headerlink" title="思路:自顶向下递归,比较左右一对节点是否相同"></a>思路:自顶向下递归,比较左右一对节点是否相同</h2><p>递归终止条件:</p>
<ol>
<li>左右同时没有子节点,对称</li>
<li>有左无右或者有右无左,不对称</li>
<li>左右值不相同,不对称 </li>
</ol>
<h3 id="show-me-code-4"><a href="#show-me-code-4" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(TreeNode *left, TreeNode *right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!left &amp;&amp; !right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (!left || !right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (left-&gt;val != right-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="comment">// 对称条件: 左子树的左=右子树的右 且 左子树的右=右子树的左</span></span><br><span class="line">    <span class="keyword">return</span> judge(left-&gt;left, right-&gt;right) &amp;&amp; judge(left-&gt;right, right-&gt;left);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isSymmetric</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 空树也是对称的</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> judge(root-&gt;left, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-4"><a href="#测试用例-4" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">    TreeNode *l2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    TreeNode *r2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    TreeNode *l3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    TreeNode *r3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    root-&gt;left = l2;</span><br><span class="line">    root-&gt;right = r2;</span><br><span class="line">    l2-&gt;right = l3;</span><br><span class="line">    r2-&gt;right = r3;</span><br><span class="line">    isSymmetric(root) ? <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;对称的&quot;</span> &lt;&lt; <span class="built_in">endl</span> : <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;不对称&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer32（一）：不分行从上往下打印二叉树"><a href="#剑指Offer32（一）：不分行从上往下打印二叉树" class="headerlink" title="剑指Offer32（一）：不分行从上往下打印二叉树"></a>剑指Offer32（一）：不分行从上往下打印二叉树</h1><p>题目：从上往下打印出二叉树的每个结点，同一层的结点按照从左到右的顺序打印</p>
<h2 id="思路-层序遍历"><a href="#思路-层序遍历" class="headerlink" title="思路:层序遍历"></a>思路:层序遍历</h2><p>二叉树的前/中/后遍历可以递归实现,即使用栈结构</p>
<p>层序遍历无法递归,用队列实现</p>
<h3 id="show-me-code-5"><a href="#show-me-code-5" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">levelOrder</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>&lt;TreeNode *&gt; deq; <span class="comment">// 队列中存的是*节点*</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    deq.push_back(root);</span><br><span class="line">    <span class="keyword">while</span> (!deq.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *node = deq.front();</span><br><span class="line">        res.push_back(node-&gt;val); <span class="comment">// 插入队列头元素</span></span><br><span class="line">        <span class="comment">// 子节点入队列</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            deq.push_back(node-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            deq.push_back(node-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        deq.pop_front();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-5"><a href="#测试用例-5" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *node3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    TreeNode *node9 = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line">    TreeNode *node20 = <span class="keyword">new</span> TreeNode(<span class="number">20</span>);</span><br><span class="line">    TreeNode *node15 = <span class="keyword">new</span> TreeNode(<span class="number">15</span>);</span><br><span class="line">    TreeNode *node7 = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">    node3-&gt;left = node9;</span><br><span class="line">    node3-&gt;right = node20;</span><br><span class="line">    node20-&gt;left = node15;</span><br><span class="line">    node20-&gt;right = node7;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = levelOrder(node3);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; res[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer32（二）：分行从上到下打印二叉树"><a href="#剑指Offer32（二）：分行从上到下打印二叉树" class="headerlink" title="剑指Offer32（二）：分行从上到下打印二叉树"></a>剑指Offer32（二）：分行从上到下打印二叉树</h1><p>题目：从上到下按层打印二叉树，同一层的结点按从左到右的顺序打印，每一层打印到一行。</p>
<h2 id="思路-和32-1相比-只需要添加两个变量"><a href="#思路-和32-1相比-只需要添加两个变量" class="headerlink" title="思路:和32_1相比,只需要添加两个变量"></a>思路:和32_1相比,只需要添加两个变量</h2><p>一个记录当前层等待输出的个数cur,另一个记录下一层的个数next</p>
<h3 id="show-me-code-6"><a href="#show-me-code-6" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode *root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>&lt;TreeNode *&gt; deq;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res_level; <span class="comment">// 每一层的值</span></span><br><span class="line">    deq.push_back(root);</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!deq.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *node = deq.front();</span><br><span class="line">        res_level.push_back(node-&gt;val);</span><br><span class="line">        <span class="comment">// 子节点入队列</span></span><br><span class="line">        <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">        &#123;</span><br><span class="line">            deq.push_back(node-&gt;left);</span><br><span class="line">            next++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">        &#123;</span><br><span class="line">            deq.push_back(node-&gt;right);</span><br><span class="line">            next++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// node出队列</span></span><br><span class="line">        deq.pop_front();</span><br><span class="line">        cur--;</span><br><span class="line">        <span class="comment">// 当cur为0,即当前层的都放到vector中了</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(res_level);</span><br><span class="line">            res_level.clear(); <span class="comment">// 清空当前层</span></span><br><span class="line">            cur = next;</span><br><span class="line">            next = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-6"><a href="#测试用例-6" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *node3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    TreeNode *node9 = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line">    TreeNode *node20 = <span class="keyword">new</span> TreeNode(<span class="number">20</span>);</span><br><span class="line">    TreeNode *node15 = <span class="keyword">new</span> TreeNode(<span class="number">15</span>);</span><br><span class="line">    TreeNode *node7 = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">    node3-&gt;left = node9;</span><br><span class="line">    node3-&gt;right = node20;</span><br><span class="line">    node20-&gt;left = node15;</span><br><span class="line">    node20-&gt;right = node7;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res = levelOrder(node3);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res[i].size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; res[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer32（三）：之字形打印二叉树"><a href="#剑指Offer32（三）：之字形打印二叉树" class="headerlink" title="剑指Offer32（三）：之字形打印二叉树"></a>剑指Offer32（三）：之字形打印二叉树</h1><p>题目：请实现一个函数按照之字形顺序打印二叉树</p>
<p>即第一行按照从左到右的顺序打印，第二层按照从右到左的顺序打印，第三行再按照从左到右的顺序打印，其他行以此类推。</p>
<h2 id="思路1-利用双向队列"><a href="#思路1-利用双向队列" class="headerlink" title="思路1:利用双向队列"></a>思路1:利用双向队列</h2><ol>
<li>在32_2基础上,添加奇偶标志位</li>
<li>奇数层,从左至右输出,所以前取后放</li>
<li>偶数层,从右至左输出,所以后取前放</li>
</ol>
<h3 id="show-me-code-7"><a href="#show-me-code-7" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrder(TreeNode *root)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">deque</span>&lt;TreeNode *&gt; deq;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res_level; <span class="comment">// 每一层的值</span></span><br><span class="line">    <span class="keyword">bool</span> isOdd = <span class="literal">true</span>;     <span class="comment">// 奇偶标志位</span></span><br><span class="line">    TreeNode *node;</span><br><span class="line">    deq.push_back(root);</span><br><span class="line">    <span class="keyword">int</span> cur = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> next = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!deq.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 奇数层,从左至右输出,所以前取后放</span></span><br><span class="line">        <span class="keyword">if</span> (isOdd)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 前取</span></span><br><span class="line">            node = deq.front();</span><br><span class="line">            res_level.push_back(node-&gt;val);</span><br><span class="line">            deq.pop_front();</span><br><span class="line">            cur--;</span><br><span class="line">            <span class="comment">// 后放</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                deq.push_back(node-&gt;left);</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                deq.push_back(node-&gt;right);</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 偶数层,从右至左输出,所以后取前放</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 后取</span></span><br><span class="line">            node = deq.back();</span><br><span class="line">            res_level.push_back(node-&gt;val);</span><br><span class="line">            deq.pop_back();</span><br><span class="line">            cur--;</span><br><span class="line">            <span class="comment">// 前放</span></span><br><span class="line">            <span class="keyword">if</span> (node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                deq.push_front(node-&gt;right);</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                deq.push_front(node-&gt;left);</span><br><span class="line">                next++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当cur为0,即当前层的都放到vector中了</span></span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(res_level);</span><br><span class="line">            res_level.clear(); <span class="comment">// 清空当前层</span></span><br><span class="line">            isOdd = !isOdd;    <span class="comment">// 切换奇偶</span></span><br><span class="line">            cur = next;</span><br><span class="line">            next = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="测试用例-7"><a href="#测试用例-7" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// TreeNode* node3 = new TreeNode(3);</span></span><br><span class="line">    <span class="comment">// TreeNode* node9 = new TreeNode(9);</span></span><br><span class="line">    <span class="comment">// TreeNode* node20 = new TreeNode(20);</span></span><br><span class="line">    <span class="comment">// TreeNode* node15 = new TreeNode(15);</span></span><br><span class="line">    <span class="comment">// TreeNode* node7 = new TreeNode(7);</span></span><br><span class="line">    <span class="comment">// node3-&gt;left = node9;</span></span><br><span class="line">    <span class="comment">// node3-&gt;right = node20;</span></span><br><span class="line">    <span class="comment">// node20-&gt;left = node15;</span></span><br><span class="line">    <span class="comment">// node20-&gt;right = node7;</span></span><br><span class="line">    <span class="comment">// vector&lt;vector&lt;int&gt;&gt; res = levelOrder(node3);</span></span><br><span class="line">    TreeNode *node1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">    TreeNode *node2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    node1-&gt;left = node2;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res = levelOrder(node1);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.size(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; res[i].size(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; res[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer33：二叉搜索树的后序遍历序列"><a href="#剑指Offer33：二叉搜索树的后序遍历序列" class="headerlink" title="剑指Offer33：二叉搜索树的后序遍历序列"></a>剑指Offer33：二叉搜索树的后序遍历序列</h1><p>题目：输入一个整数数组，判断该数组是不是某二叉搜索树的后序遍历的结果。<br>如果是则返回true，否则返回false。假设输入的数组的任意两个数字都互不相同。</p>
<h2 id="思路-1"><a href="#思路-1" class="headerlink" title="思路:"></a>思路:</h2><p>BST的后序遍历满足两个条件:</p>
<ol>
<li>左子树&lt;根&lt;右子树</li>
<li>最后一个数字是根节点</li>
<li>找到左右子树的序列,并<em>递归</em>检查左右子树是不是后序遍历序列<br>递归终止条件:序列的左右断点重合,即无法再分出子树</li>
</ol>
<h3 id="show-me-code-8"><a href="#show-me-code-8" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">recursion</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">verifyPostorder</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;postorder)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recursion(postorder, <span class="number">0</span>, postorder.size() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">recursion</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;vec, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 递归终止条件</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> root = vec[right]; <span class="comment">// 根节点</span></span><br><span class="line">    <span class="comment">// 根据左子树&lt;根节点,找左子树[left,divide-1]</span></span><br><span class="line">    <span class="keyword">int</span> divide = left; <span class="comment">// 设置一个divide变量可以避免超时</span></span><br><span class="line">    <span class="keyword">for</span> (; divide &lt; right; divide++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (vec[divide] &gt; root)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查右子树[divide,right]&gt;根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = divide; j &lt; right; j++)</span><br><span class="line">    &#123; /这里不是j &lt; right<span class="number">-1</span>*</span><br><span class="line">        <span class="keyword">if</span> (vec[j] &lt; root)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 上面已经把遍历序列分成:左子树[left,divide-1];右子树[divide,right-1]</span></span><br><span class="line">    <span class="comment">// 左右子树都要满足,因此用&amp;&amp;连接</span></span><br><span class="line">    <span class="keyword">return</span> recursion(vec, left, divide - <span class="number">1</span>) &amp;&amp; recursion(vec, divide, right - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-8"><a href="#测试用例-8" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 测试1输出false</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in1 = &#123;<span class="number">1</span>, <span class="number">6</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (verifyPostorder(in1))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 测试2输出false</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; in2 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">4</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">if</span> (verifyPostorder(in2))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer34：二叉树中和为某一值的路径"><a href="#剑指Offer34：二叉树中和为某一值的路径" class="headerlink" title="剑指Offer34：二叉树中和为某一值的路径"></a>剑指Offer34：二叉树中和为某一值的路径</h1><p>题目：输入一棵二叉树和一个整数，打印出二叉树中结点值的和为输入整数的所有路径。<br>从树的根结点开始往下一直到叶结点所经过的结点形成一条路径。</p>
<h2 id="思路-前序遍历-回溯"><a href="#思路-前序遍历-回溯" class="headerlink" title="思路:前序遍历+回溯"></a>思路:前序遍历+回溯</h2><p>当遍历到叶子节点后,检查当前路径的长度<br>一层递归结束后,需要弹出path末端的节点<br>递归终点:到左右子节点为空 </p>
<h3 id="show-me-code-9"><a href="#show-me-code-9" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recursion</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; sum, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; res, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span>&amp; p_sum)</span> </span>&#123;</span><br><span class="line">    path.push_back(root-&gt;val);</span><br><span class="line">    <span class="comment">// 到叶子节点,检查当前路径长度</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; path.size();i++) &#123;</span><br><span class="line">            p_sum += path[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p_sum == sum) &#123;</span><br><span class="line">            res.push_back(path);</span><br><span class="line">        &#125;</span><br><span class="line">        p_sum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left)</span><br><span class="line">        recursion(root-&gt;left, sum, res, path, p_sum);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right)</span><br><span class="line">        recursion(root-&gt;right, sum, res, path, p_sum);</span><br><span class="line">    path.pop_back();<span class="comment">// 返回父节点的时候要从数组中pop末端节点</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; pathSum(TreeNode* root, <span class="keyword">int</span> sum) &#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">int</span> p_sum = <span class="number">0</span>;</span><br><span class="line">    recursion(root, sum, res, path, p_sum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-9"><a href="#测试用例-9" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span> </span>&#123;</span><br><span class="line">    TreeNode* n5 = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">    TreeNode* n4 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">    TreeNode* n8 = <span class="keyword">new</span> TreeNode(<span class="number">8</span>);</span><br><span class="line">    TreeNode* n11 = <span class="keyword">new</span> TreeNode(<span class="number">11</span>);</span><br><span class="line">    TreeNode* n13 = <span class="keyword">new</span> TreeNode(<span class="number">13</span>);</span><br><span class="line">    TreeNode* n4_ = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">    TreeNode* n7 = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">    TreeNode* n2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    TreeNode* n5_ = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">    TreeNode* n1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">    n5-&gt;left = n4;</span><br><span class="line">    n5-&gt;right = n8;</span><br><span class="line">    n4-&gt;left = n11;</span><br><span class="line">    n8-&gt;left = n13;</span><br><span class="line">    n8-&gt;right = n4_;</span><br><span class="line">    n11-&gt;left = n7;</span><br><span class="line">    n11-&gt;right = n2;</span><br><span class="line">    n4_-&gt;left = n5_;</span><br><span class="line">    n4_-&gt;right = n1;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res = pathSum(n5, <span class="number">22</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; res.size();i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; res[i].size();j++) &#123;</span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; res[i][j] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer36：二叉搜索树与双向链表"><a href="#剑指Offer36：二叉搜索树与双向链表" class="headerlink" title="剑指Offer36：二叉搜索树与双向链表"></a>剑指Offer36：二叉搜索树与双向链表</h1><p>题目：输入一棵二叉搜索树，将该二叉搜索树转换成一个排序的双向链表。要求<br>不能创建任何新的结点，只能调整树中结点指针的指向。</p>
<h2 id="思路-2"><a href="#思路-2" class="headerlink" title="思路:"></a>思路:</h2><ol>
<li>本题目需要返回的是循环双向队列<br>2。 BST的中序遍历就是递增序列</li>
<li>先定义head和tail指针,head指向左递归的终点,tail随着递归的回溯向后移动</li>
<li>最后将头尾连接起来,实现循环</li>
</ol>
<h3 id="show-me-code-10"><a href="#show-me-code-10" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">Node *head, *tail = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    dfs(root-&gt;left);</span><br><span class="line">    <span class="comment">// head指针在左递归尽头就确定不变了</span></span><br><span class="line">    <span class="comment">// tail指针只有当第一次左递归到头的时候是NULL</span></span><br><span class="line">    <span class="comment">// tail用作一个判断,tail非空表示已经发生回溯,root指向tail的后一个数字</span></span><br><span class="line">    <span class="keyword">if</span> (!tail)</span><br><span class="line">    &#123;</span><br><span class="line">        head = root; <span class="comment">// head指向BST的左递归尽头</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// root已经回溯到tail后一个数字</span></span><br><span class="line">        tail-&gt;right = root;</span><br><span class="line">        root-&gt;left = tail;</span><br><span class="line">    &#125;</span><br><span class="line">    tail = root; <span class="comment">// 左递归到头之后tail就不是NULL了</span></span><br><span class="line">    dfs(root-&gt;right);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Node *<span class="title">treeToDoublyList</span><span class="params">(Node *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    dfs(root);</span><br><span class="line">    head-&gt;left = tail;</span><br><span class="line">    tail-&gt;right = head;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-10"><a href="#测试用例-10" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Node *n1 = <span class="keyword">new</span> Node(<span class="number">1</span>);</span><br><span class="line">    Node *n3 = <span class="keyword">new</span> Node(<span class="number">3</span>);</span><br><span class="line">    Node *n2 = <span class="keyword">new</span> Node(<span class="number">2</span>, n1, n3);</span><br><span class="line">    Node *n5 = <span class="keyword">new</span> Node(<span class="number">5</span>);</span><br><span class="line">    Node *n4 = <span class="keyword">new</span> Node(<span class="number">4</span>, n2, n5);</span><br><span class="line">    Node *<span class="built_in">list</span> = treeToDoublyList(n4);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">list</span>-&gt;val &lt;&lt; <span class="string">&quot; left: &quot;</span> &lt;&lt; <span class="built_in">list</span>-&gt;left-&gt;val &lt;&lt; <span class="string">&quot; right: &quot;</span> &lt;&lt; <span class="built_in">list</span>-&gt;right-&gt;val &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer37-序列化二叉树"><a href="#剑指Offer37-序列化二叉树" class="headerlink" title="剑指Offer37. 序列化二叉树"></a>剑指Offer37. 序列化二叉树</h1><p>题目：请实现两个函数，分别用来序列化和反序列化二叉树。<br>说明: 不要使用类的成员 / 全局 / 静态变量来存储状态，你的序列化和反序列化算法应该是无状态的。 </p>
<h2 id="思路-3"><a href="#思路-3" class="headerlink" title="思路:"></a>思路:</h2><p>序列化的方式和书上不一样,书上是前序遍历,LeetCode上面是层序遍历。其实根据题目意思,只要反序列化后能和之前一样,就没问题<br>关于层序遍历,可以先看LeetCode102,要用到BFS广度优先遍历<br>注意：这里末尾输出会包含很多null,即叶子节点的子节点，但是只要能够反序列化成原始的状态,就能通过测试 </p>
<h3 id="show-me-code-11"><a href="#show-me-code-11" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">string</span> <span class="title">serialize</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="built_in">ostringstream</span> res;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; bfs;</span><br><span class="line">    bfs.push(root);</span><br><span class="line">    <span class="keyword">while</span> (!bfs.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        TreeNode *node = bfs.front();</span><br><span class="line">        bfs.pop();</span><br><span class="line">        <span class="keyword">if</span> (node != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bfs.push(node-&gt;left);</span><br><span class="line">            bfs.push(node-&gt;right);</span><br><span class="line">            res &lt;&lt; node-&gt;val &lt;&lt; <span class="string">&#x27;,&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res &lt;&lt; <span class="string">&quot;null,&quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res.str();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode *<span class="title">deserialize</span><span class="params">(<span class="built_in">string</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (data.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">istringstream</span> <span class="title">node_steam</span><span class="params">(data)</span></span>; <span class="comment">// 从data中读取string数据,会自动分割</span></span><br><span class="line">    <span class="built_in">string</span> node;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode *&gt; res; <span class="comment">// 用vector存储节点,方便索引</span></span><br><span class="line">    <span class="keyword">while</span> (getline(</span><br><span class="line">        node_steam, node,</span><br><span class="line">        <span class="string">&#x27;,&#x27;</span>))</span><br><span class="line">    &#123; <span class="comment">// 这里要用到getline指定分隔符,如果是空格分隔符,直接用node_stream</span></span><br><span class="line">        <span class="comment">// &gt;&gt; node就好了</span></span><br><span class="line">        <span class="keyword">if</span> (node == <span class="string">&quot;null&quot;</span>)</span><br><span class="line">        &#123; <span class="comment">// 这里不是&quot;null,&quot;分隔符会自动去除</span></span><br><span class="line">            res.push_back(<span class="literal">NULL</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(<span class="keyword">new</span> TreeNode(stoi(node)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 下面要将vector中的指针连起来</span></span><br><span class="line">    <span class="comment">// 很巧妙的做法,用两个指针i和j</span></span><br><span class="line">    <span class="comment">// i是vector的索引指针,一次循环移动一次</span></span><br><span class="line">    <span class="comment">// j是左右指针的索引,由于序列化的顺序是:a(根)-a左(b)-a右(c)-b(左)-b(右)...</span></span><br><span class="line">    <span class="comment">// 因此j可以用来索引左右节点</span></span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">1</span>; <span class="comment">// 跳过根节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; j &lt; res.size();</span><br><span class="line">         i++)</span><br><span class="line">    &#123; <span class="comment">// 因为j比i增长的快,因此用j做判断条件可以防止数组越界</span></span><br><span class="line">        <span class="keyword">if</span> (!res[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i]-&gt;left = res[j++]; <span class="comment">// 先res[j]再j++</span></span><br><span class="line">        <span class="keyword">if</span> (j &lt; res.size())</span><br><span class="line">        &#123; <span class="comment">// 防止越界</span></span><br><span class="line">            res[i]-&gt;right = res[j++];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res[<span class="number">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-11"><a href="#测试用例-11" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *n1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">    TreeNode *n2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    TreeNode *n3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    TreeNode *n4 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">    TreeNode *n5 = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">    n1-&gt;left = n2;</span><br><span class="line">    n1-&gt;right = n3;</span><br><span class="line">    n3-&gt;left = n4;</span><br><span class="line">    n3-&gt;right = n5;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;原树: &quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printTree(n1);</span><br><span class="line">    <span class="built_in">string</span> out = serialize(n1);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;序列化后:&quot;</span> &lt;&lt; out &lt;&lt; <span class="string">&#x27;\n&#x27;</span></span><br><span class="line">         &lt;&lt; <span class="string">&quot;反序列化后:&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    printTree(deserialize(out));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="剑指Offer54：二叉搜索树的第k个结点"><a href="#剑指Offer54：二叉搜索树的第k个结点" class="headerlink" title="剑指Offer54：二叉搜索树的第k个结点"></a>剑指Offer54：二叉搜索树的第k个结点</h1><p>题目：给定一棵二叉搜索树，请找出其中的第k大的结点。</p>
<h2 id="思路："><a href="#思路：" class="headerlink" title="思路："></a>思路：</h2><p>二叉搜索树的中序遍历就是一个递增的数组<br>这道题目需要构建一个递减的数组找到第k大的数字，因此采用右-中-左的顺序</p>
<h3 id="show-me-code-12"><a href="#show-me-code-12" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>, res = <span class="number">0</span>; <span class="comment">// 全局变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(TreeNode *node, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    helper(node-&gt;right, k); <span class="comment">//右</span></span><br><span class="line">    ++count;                <span class="comment">//统计递归次数</span></span><br><span class="line">    <span class="keyword">if</span> (count == k)</span><br><span class="line">    &#123;</span><br><span class="line">        res = node-&gt;val;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    helper(node-&gt;left, k); <span class="comment">//左</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthLargest</span><span class="params">(TreeNode *root, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    helper(root, k);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-12"><a href="#测试用例-12" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *root = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    TreeNode *node1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">    TreeNode *node4 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">    TreeNode *node2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    root-&gt;left = node1;</span><br><span class="line">    root-&gt;right = node4;</span><br><span class="line">    node1-&gt;right = node2;</span><br><span class="line">    printTree(root);</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; kthLargest(root, <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer55（一）：二叉树的深度"><a href="#剑指Offer55（一）：二叉树的深度" class="headerlink" title="剑指Offer55（一）：二叉树的深度"></a>剑指Offer55（一）：二叉树的深度</h1><p>题目：输入一棵二叉树的根结点，求该树的深度。<br>从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度。</p>
<h2 id="思路1：层序遍历"><a href="#思路1：层序遍历" class="headerlink" title="思路1：层序遍历"></a>思路1：层序遍历</h2><p>和剑指32一样的，对二叉树做一个层序遍历<br>不同的是用到了两个队列，一个记录当前层节点，另一个记录下一层节点</p>
<h3 id="show-me-code-13"><a href="#show-me-code-13" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;TreeNode *&gt; cur;</span><br><span class="line">    cur.push(root);</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 第一层循环：按照层数添加节点到cur队列</span></span><br><span class="line">    <span class="keyword">while</span> (!cur.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode *&gt; next; <span class="comment">// next必须在这里，保证每一层都清空</span></span><br><span class="line">        <span class="comment">// 第二层循环：把cur队列中的节点的子节点添加到next</span></span><br><span class="line">        <span class="comment">// 因为queue不支持迭代器遍历，这里用pop函数</span></span><br><span class="line">        <span class="keyword">while</span> (!cur.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 把子节点存到next</span></span><br><span class="line">            <span class="keyword">if</span> (cur.front()-&gt;left)</span><br><span class="line">                next.push(cur.front()-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (cur.front()-&gt;right)</span><br><span class="line">                next.push(cur.front()-&gt;right);</span><br><span class="line">            cur.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理下一层节点</span></span><br><span class="line">        cur = next;</span><br><span class="line">        ++cnt;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="思路2：DFS后序遍历"><a href="#思路2：DFS后序遍历" class="headerlink" title="思路2：DFS后序遍历"></a>思路2：DFS后序遍历</h2><p>找到左子树以及右子树的深度，两者中大的值+1(root)返回<br>基础的后序遍历返回值是void，这里返回的是深度值，可以理解为函数调用的次数</p>
<h3 id="show-me-code-14"><a href="#show-me-code-14" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> max(maxDepth(root-&gt;left), maxDepth(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-13"><a href="#测试用例-13" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *n3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    TreeNode *n9 = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line">    TreeNode *n20 = <span class="keyword">new</span> TreeNode(<span class="number">20</span>);</span><br><span class="line">    TreeNode *n15 = <span class="keyword">new</span> TreeNode(<span class="number">15</span>);</span><br><span class="line">    TreeNode *n7 = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">    n3-&gt;left = n9;</span><br><span class="line">    n3-&gt;right = n20;</span><br><span class="line">    n20-&gt;left = n15;</span><br><span class="line">    n20-&gt;right = n7;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxDepth(n3) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">//输出3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer55（二）：平衡二叉树"><a href="#剑指Offer55（二）：平衡二叉树" class="headerlink" title="剑指Offer55（二）：平衡二叉树"></a>剑指Offer55（二）：平衡二叉树</h1><p>题目：输入一棵二叉树的根结点，判断该树是不是平衡二叉树。<br>如果某二叉树中任意结点的左右子树的深度相差不超过1，那么它就是一棵平衡二叉树。</p>
<h2 id="思路1："><a href="#思路1：" class="headerlink" title="思路1："></a>思路1：</h2><p>用55_1_maxDepth的思路，分别找出左子树和右子树的深度<br>判断是不是两者差&lt;=1</p>
<h3 id="show-me-code-15"><a href="#show-me-code-15" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// depeth函数*递归*找到当前节点的深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode *node)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!node)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> max(depth(node-&gt;left), depth(node-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// depth函数也是*递归*确保每个节点都是平衡的</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> res = <span class="built_in">abs</span>(depth(root-&gt;left) - depth(root-&gt;right)) &lt;= <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> res &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路2：后序遍历-剪枝"><a href="#思路2：后序遍历-剪枝" class="headerlink" title="思路2：后序遍历+剪枝"></a>思路2：后序遍历+剪枝</h2><p>对二叉树做一个后序遍历，从底向上返回深度，当子树不平衡的话就剪枝直接向上返回</p>
<h3 id="show-me-code-16"><a href="#show-me-code-16" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = dfs(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> right = dfs(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (right == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">abs</span>(left - right) &lt; <span class="number">2</span> ? max(left, right) + <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode *root)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dfs(root) != <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-14"><a href="#测试用例-14" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **agrv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *n3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    TreeNode *n9 = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line">    TreeNode *n20 = <span class="keyword">new</span> TreeNode(<span class="number">20</span>);</span><br><span class="line">    TreeNode *n15 = <span class="keyword">new</span> TreeNode(<span class="number">15</span>);</span><br><span class="line">    TreeNode *n7 = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">    n3-&gt;left = n9;</span><br><span class="line">    n3-&gt;right = n20;</span><br><span class="line">    n20-&gt;left = n15;</span><br><span class="line">    n20-&gt;right = n7;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isBalanced(n3))</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;true&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;false&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer68-1：二叉搜索树的最近公共祖先"><a href="#剑指Offer68-1：二叉搜索树的最近公共祖先" class="headerlink" title="剑指Offer68-1：二叉搜索树的最近公共祖先"></a>剑指Offer68-1：二叉搜索树的最近公共祖先</h1><p>题目：给定一个二叉搜索树, 找到该树中两个指定节点的最近公共祖先。</p>
<h2 id="思路1：两次遍历找到路径"><a href="#思路1：两次遍历找到路径" class="headerlink" title="思路1：两次遍历找到路径"></a>思路1：两次遍历找到路径</h2><ol>
<li><p>对于输入的两个节点，两次遍历得到从根节点到两个节点的路径</p>
</li>
<li><p>由于是二叉搜索树，因此可以通过比对大小确定路径</p>
</li>
<li><p>最后输出两个路径上共同的点</p>
<h3 id="show-me-code-17"><a href="#show-me-code-17" class="headerlink" title="show me code"></a>show me code</h3></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="built_in">vector</span>&lt;TreeNode *&gt; <span class="title">getPath</span><span class="params">(TreeNode *root, TreeNode *target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode *&gt; path;</span><br><span class="line">    TreeNode *node = root;</span><br><span class="line">    <span class="keyword">while</span> (node != target)</span><br><span class="line">    &#123;</span><br><span class="line">        path.push_back(node);</span><br><span class="line">        <span class="keyword">if</span> (target-&gt;val &lt; node-&gt;val)</span><br><span class="line">            node = node-&gt;left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            node = node-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    path.push_back(node);</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">TreeNode *<span class="title">lowestCommonAncestor</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode *&gt; path_p = getPath(root, p);</span><br><span class="line">    <span class="built_in">vector</span>&lt;TreeNode *&gt; path_q = getPath(root, q);</span><br><span class="line">    TreeNode *ancestor;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; path_p.size() &amp;&amp; i &lt; path_q.size(); ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (path_p[i] == path_q[i])</span><br><span class="line">            ancestor = path_p[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ancestor;</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>
<h2 id="思路2：一次遍历"><a href="#思路2：一次遍历" class="headerlink" title="思路2：一次遍历"></a>思路2：一次遍历</h2><ol>
<li>p,q都在root左子树，root遍历至左节点</li>
<li>p,q都在root右子树，root遍历至右节点</li>
<li>p,q分别在root的左右两边，说明找到了祖先节点<h3 id="show-me-code-18"><a href="#show-me-code-18" class="headerlink" title="show me code"></a>show me code</h3></li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">lowestCommonAncestor</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val)</span><br><span class="line">            root = root-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val)</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="思路3：递归"><a href="#思路3：递归" class="headerlink" title="思路3：递归"></a>思路3：递归</h2><h3 id="show-me-code-19"><a href="#show-me-code-19" class="headerlink" title="show me code"></a>show me code</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">lowestCommonAncestor</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;val &lt; root-&gt;val &amp;&amp; q-&gt;val &lt; root-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    <span class="keyword">if</span> (p-&gt;val &gt; root-&gt;val &amp;&amp; q-&gt;val &gt; root-&gt;val)</span><br><span class="line">        <span class="keyword">return</span> lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-15"><a href="#测试用例-15" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *n6 = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">    TreeNode *n2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    TreeNode *n8 = <span class="keyword">new</span> TreeNode(<span class="number">8</span>);</span><br><span class="line">    TreeNode *n0 = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">    TreeNode *n4 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">    TreeNode *n7 = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">    TreeNode *n9 = <span class="keyword">new</span> TreeNode(<span class="number">9</span>);</span><br><span class="line">    TreeNode *n3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    TreeNode *n5 = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">    n6-&gt;left = n2;</span><br><span class="line">    n6-&gt;right = n8;</span><br><span class="line">    n2-&gt;left = n0;</span><br><span class="line">    n2-&gt;right = n4;</span><br><span class="line">    n8-&gt;left = n7;</span><br><span class="line">    n8-&gt;right = n9;</span><br><span class="line">    n4-&gt;left = n3;</span><br><span class="line">    n4-&gt;right = n5;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; lowestCommonAncestor(n6, n2, n4)-&gt;val &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="剑指Offer68-2：二叉树的最近公共祖先"><a href="#剑指Offer68-2：二叉树的最近公共祖先" class="headerlink" title="剑指Offer68-2：二叉树的最近公共祖先"></a>剑指Offer68-2：二叉树的最近公共祖先</h1><p>题目：给定一个二叉树, 找到该树中两个指定节点的最近公共祖先。</p>
<h2 id="思路：递归"><a href="#思路：递归" class="headerlink" title="思路：递归"></a>思路：递归</h2><ol>
<li>在root的左子树递归查找p,q</li>
<li>在root的右子树递归查找p,q</li>
<li>p,q的分布存在四种情况<ol>
<li>左右都不在，返回nullptr</li>
<li>左边和右边都存在，返回root</li>
<li>只在左边找到了，返回root-&gt;left</li>
<li>只在右边找到了，返回root-&gt;right<h3 id="show-me-code-20"><a href="#show-me-code-20" class="headerlink" title="show me code"></a>show me code</h3></li>
</ol>
</li>
</ol>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode *<span class="title">lowestCommonAncestor</span><span class="params">(TreeNode *root, TreeNode *p, TreeNode *q)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!root || !p || !q || p == root || q == root)</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    TreeNode *left = lowestCommonAncestor(root-&gt;left, p, q);</span><br><span class="line">    TreeNode *right = lowestCommonAncestor(root-&gt;right, p, q);</span><br><span class="line">    <span class="keyword">if</span> (!left &amp;&amp; !right)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">if</span> (left &amp;&amp; !right)</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">if</span> (!left &amp;&amp; right)</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="测试用例-16"><a href="#测试用例-16" class="headerlink" title="测试用例"></a>测试用例</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TreeNode *n3 = <span class="keyword">new</span> TreeNode(<span class="number">3</span>);</span><br><span class="line">    TreeNode *n5 = <span class="keyword">new</span> TreeNode(<span class="number">5</span>);</span><br><span class="line">    TreeNode *n1 = <span class="keyword">new</span> TreeNode(<span class="number">1</span>);</span><br><span class="line">    TreeNode *n6 = <span class="keyword">new</span> TreeNode(<span class="number">6</span>);</span><br><span class="line">    TreeNode *n2 = <span class="keyword">new</span> TreeNode(<span class="number">2</span>);</span><br><span class="line">    TreeNode *n0 = <span class="keyword">new</span> TreeNode(<span class="number">0</span>);</span><br><span class="line">    TreeNode *n8 = <span class="keyword">new</span> TreeNode(<span class="number">8</span>);</span><br><span class="line">    TreeNode *n7 = <span class="keyword">new</span> TreeNode(<span class="number">7</span>);</span><br><span class="line">    TreeNode *n4 = <span class="keyword">new</span> TreeNode(<span class="number">4</span>);</span><br><span class="line">    n3-&gt;left = n5;</span><br><span class="line">    n3-&gt;right = n1;</span><br><span class="line">    n5-&gt;left = n6;</span><br><span class="line">    n5-&gt;right = n2;</span><br><span class="line">    n1-&gt;left = n0;</span><br><span class="line">    n1-&gt;right = n8;</span><br><span class="line">    n2-&gt;left = n7;</span><br><span class="line">    n2-&gt;right = n4;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; lowestCommonAncestor(n3, n5, n4)-&gt;val &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>剑指Offer</tag>
        <tag>二叉树</tag>
      </tags>
  </entry>
</search>
